<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODrive Motor Control</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        body {
            background-color: #f5f5f5;
            padding: 20px;
        }
        .card {
            margin-bottom: 20px;
        }
        .status-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .status-connected {
            background-color: #28a745;
        }
        .status-disconnected {
            background-color: #dc3545;
        }
        .status-warning {
            background-color: #ffc107;
        }
        .emergency-stop {
            font-size: 1.5rem;
            padding: 20px;
            font-weight: bold;
        }
        .preset-btn {
            margin: 5px;
        }
        .value-display {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
        }
        .chart-container {
            position: relative;
            height: 300px;
        }
        #joystickCanvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: crosshair;
            background-color: #f8f9fa;
            touch-action: none;
        }
        #joystickCanvas:active {
            cursor: grabbing;
        }
        .control-mode-tabs {
            margin-bottom: 15px;
        }
        .control-section {
            display: block;
        }
        #rotationKnobContainer {
            text-align: center;
        }
        #rotationKnobSvg {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            background-color: #f8f9fa;
            cursor: grab;
            touch-action: none;
            user-select: none;
        }
        #rotationKnobSvg:active {
            cursor: grabbing;
        }
        .knob-body {
            fill: url(#knobGradient);
            stroke: #6c757d;
            stroke-width: 2;
        }
        .knob-pointer {
            stroke: #dc3545;
            stroke-width: 3;
            stroke-linecap: round;
        }
        .knob-grip-line {
            stroke: #495057;
            stroke-width: 2;
            opacity: 0.6;
        }
        .knob-reference-mark {
            fill: #0d6efd;
        }
        .blink {
            animation: blink-animation 1s infinite;
        }
        @keyframes blink-animation {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="text-center mb-4">ODrive Motor Control</h1>

        <!-- Status Bar -->
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <span class="status-indicator" id="connectionStatus"></span>
                        <span id="connectionText">Connecting...</span>
                    </div>
                    <div>
                        <strong>Motor State:</strong> <span id="motorState">Unknown</span>
                    </div>
                    <div>
                        <button class="btn btn-secondary" onclick="requestConfig()">Get Config</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Control Panel -->
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5>Controls</h5>
                    </div>
                    <div class="card-body">
                        <!-- Emergency Stop -->
                        <button class="btn btn-danger w-100 emergency-stop" onclick="emergencyStop()">
                            ðŸ›‘ EMERGENCY STOP
                        </button>

                        <hr>

                        <!-- Control Mode Tabs -->
                        <div class="btn-group control-mode-tabs w-100" role="group">
                            <input type="radio" class="btn-check" name="controlMode" id="velocityMode" checked autocomplete="off">
                            <label class="btn btn-outline-primary" for="velocityMode">Velocity</label>

                            <input type="radio" class="btn-check" name="controlMode" id="joystickMode" autocomplete="off">
                            <label class="btn btn-outline-primary" for="joystickMode">Joystick</label>

                            <input type="radio" class="btn-check" name="controlMode" id="rotationMode" autocomplete="off">
                            <label class="btn btn-outline-primary" for="rotationMode">Rotation Knob</label>

                            <input type="radio" class="btn-check" name="controlMode" id="ikMode" autocomplete="off">
                            <label class="btn btn-outline-primary" for="ikMode">IK Control</label>
                        </div>

                        <hr>

                        <!-- Velocity Control -->
                        <div id="velocityControls" class="control-section">
                        <h6>Velocity Control</h6>
                        <div class="mb-3">
                            <label for="velocitySlider" class="form-label">
                                Velocity: <span id="velocityValue">0.0</span> turns/sec
                            </label>
                            <input type="range" class="form-range" id="velocitySlider"
                                   min="-10" max="10" step="0.1" value="0"
                                   oninput="updateVelocityDisplay(this.value)">
                        </div>

                        <!-- Preset Speeds -->
                        <div class="mb-3">
                            <label class="form-label">Preset Speeds:</label>
                            <div>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(-10)">-10</button>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(-5)">-5</button>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(-1)">-1</button>
                                <button class="btn btn-sm btn-outline-secondary preset-btn" onclick="setVelocity(0)">0</button>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(1)">+1</button>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(5)">+5</button>
                                <button class="btn btn-sm btn-outline-primary preset-btn" onclick="setVelocity(10)">+10</button>
                            </div>
                        </div>

                        <!-- Fine Control -->
                        <div class="mb-3">
                            <label class="form-label">Fine Control:</label>
                            <div class="btn-group w-100" role="group">
                                <button class="btn btn-outline-secondary" onclick="adjustVelocity(-0.5)">-0.5</button>
                                <button class="btn btn-outline-secondary" onclick="adjustVelocity(-0.1)">-0.1</button>
                                <button class="btn btn-outline-secondary" onclick="adjustVelocity(0.1)">+0.1</button>
                                <button class="btn btn-outline-secondary" onclick="adjustVelocity(0.5)">+0.5</button>
                            </div>
                        </div>

                        <button class="btn btn-success w-100" onclick="applyVelocity()">Apply Velocity</button>

                        <hr>

                        <!-- Position Control -->
                        <h6>Position Control</h6>
                        <div class="input-group mb-3">
                            <input type="number" class="form-control" id="positionInput"
                                   placeholder="Target position" step="0.1">
                            <button class="btn btn-info" onclick="goToPosition()">Go To Position</button>
                        </div>

                        <!-- ODrive Position Scaling -->
                        <div class="mb-3">
                            <label for="positionScaleFactor" class="form-label">
                                Position Scale Factor: <span id="scaleFactorValue">10.0</span>x
                            </label>
                            <input type="range" class="form-range" id="positionScaleFactor"
                                   min="0.1" max="20" step="0.1" value="10"
                                   oninput="updateScaleFactorDisplay(this.value)">
                            <small class="text-muted">Adjust if motor doesn't rotate correctly (default: 10x)</small>
                        </div>

                        <!-- Velocity Ramping Controls -->
                        <div class="mb-3">
                            <div class="form-check form-switch mb-2">
                                <input class="form-check-input" type="checkbox" id="velocityRampingEnabled" checked
                                       onchange="toggleVelocityRamping(this.checked)">
                                <label class="form-check-label" for="velocityRampingEnabled">
                                    Velocity Ramping (Smooth Acceleration)
                                </label>
                            </div>
                            <div id="velocityRampingControls">
                                <label for="accelerationLimit" class="form-label">
                                    Acceleration: <span id="accelerationValue">5.0</span> turns/secÂ²
                                </label>
                                <input type="range" class="form-range" id="accelerationLimit"
                                       min="0.5" max="20" step="0.5" value="5"
                                       oninput="updateAccelerationDisplay(this.value)">
                                <label for="decelerationLimit" class="form-label mt-2">
                                    Deceleration: <span id="decelerationValue">5.0</span> turns/secÂ²
                                </label>
                                <input type="range" class="form-range" id="decelerationLimit"
                                       min="0.5" max="20" step="0.5" value="5"
                                       oninput="updateDecelerationDisplay(this.value)">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i> Controls how quickly velocity changes
                                </small>
                            </div>
                        </div>

                        <hr>

                        <!-- Position Presets & Waypoints Section -->
                        <h6>Position Presets</h6>
                        <div class="mb-3">
                            <div id="presetsList" class="d-flex flex-wrap gap-2 mb-2">
                                <!-- Dynamically populated preset buttons -->
                            </div>
                            <div class="btn-group w-100 mb-2" role="group">
                                <button class="btn btn-sm btn-success" onclick="saveCurrentAsPreset()">
                                    <i class="bi bi-bookmark-plus"></i> Save Current
                                </button>
                                <button class="btn btn-sm btn-info" onclick="openPresetManager()">
                                    <i class="bi bi-gear"></i> Manage
                                </button>
                            </div>
                        </div>

                        <hr>

                        <h6>Waypoint Sequences</h6>
                        <div class="mb-3">
                            <select id="waypointSelect" class="form-select form-select-sm mb-2">
                                <option value="">-- Select Waypoint --</option>
                                <!-- Dynamically populated -->
                            </select>
                            <div class="btn-group w-100 mb-2" role="group">
                                <button class="btn btn-sm btn-primary" onclick="executeWaypoint()" id="executeWaypointBtn">
                                    <i class="bi bi-play-fill"></i> Execute
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="stopWaypoint()" id="stopWaypointBtn" disabled>
                                    <i class="bi bi-stop-fill"></i> Stop
                                </button>
                            </div>
                            <button class="btn btn-sm btn-info w-100" onclick="openWaypointBuilder()">
                                <i class="bi bi-plus-circle"></i> Create Waypoint
                            </button>
                        </div>

                        <hr>

                        <!-- Auto-Calibration Section -->
                        <h6>Auto-Calibration</h6>
                        <div class="mb-3">
                            <div class="alert alert-info alert-sm mb-2" style="font-size: 0.85rem; padding: 0.5rem;">
                                <i class="bi bi-info-circle"></i> Automatically calibrate the position scale factor by rotating the motor exactly 1 turn.
                            </div>
                            <button class="btn btn-sm btn-primary w-100" onclick="startCalibration()" id="startCalibrationBtn">
                                <i class="bi bi-tools"></i> Start Calibration
                            </button>
                            <div id="calibrationProgress" class="mt-2" style="display: none;">
                                <div class="progress mb-2">
                                    <div id="calibrationProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                                         role="progressbar" style="width: 0%"></div>
                                </div>
                                <small id="calibrationStatus" class="text-muted">Initializing...</small>
                            </div>
                        </div>

                        <hr>

                        <!-- Motion Recording & Playback Section -->
                        <h6>Motion Recording & Playback</h6>
                        <div class="mb-3">
                            <!-- Recording Controls -->
                            <div class="mb-2">
                                <div class="btn-group w-100" role="group">
                                    <button class="btn btn-sm btn-danger" onclick="startRecording()" id="startRecordingBtn">
                                        <i class="bi bi-record-circle"></i> Record
                                    </button>
                                    <button class="btn btn-sm btn-secondary" onclick="stopRecording()" id="stopRecordingBtn" disabled>
                                        <i class="bi bi-stop-circle"></i> Stop
                                    </button>
                                </div>
                                <div id="recordingIndicator" class="mt-2" style="display: none;">
                                    <div class="alert alert-danger alert-sm mb-0" style="font-size: 0.85rem; padding: 0.5rem;">
                                        <i class="bi bi-record-fill blink"></i> Recording... <span id="recordingDuration">0:00</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Sequence Library -->
                            <div class="mb-2">
                                <select id="sequenceSelect" class="form-select form-select-sm mb-2">
                                    <option value="">-- Select Sequence --</option>
                                </select>
                                <div class="btn-group w-100 mb-2" role="group">
                                    <button class="btn btn-sm btn-success" onclick="playSequence()" id="playSequenceBtn">
                                        <i class="bi bi-play-fill"></i> Play
                                    </button>
                                    <button class="btn btn-sm btn-warning" onclick="pauseSequence()" id="pauseSequenceBtn" disabled>
                                        <i class="bi bi-pause-fill"></i> Pause
                                    </button>
                                    <button class="btn btn-sm btn-danger" onclick="stopSequence()" id="stopSequenceBtn" disabled>
                                        <i class="bi bi-stop-fill"></i> Stop
                                    </button>
                                </div>
                                <div id="playbackProgress" class="mb-2" style="display: none;">
                                    <div class="progress" style="height: 8px;">
                                        <div id="playbackProgressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                                    </div>
                                    <small class="text-muted">
                                        <span id="playbackTime">0:00</span> / <span id="playbackDuration">0:00</span>
                                        <span id="playbackSpeed" class="float-end">1.0x</span>
                                    </small>
                                </div>
                            </div>

                            <!-- Playback Speed Control -->
                            <div class="mb-2">
                                <label for="playbackSpeedSlider" class="form-label">
                                    Playback Speed: <span id="playbackSpeedValue">1.0</span>x
                                </label>
                                <input type="range" class="form-range" id="playbackSpeedSlider"
                                       min="0.1" max="3.0" step="0.1" value="1.0"
                                       oninput="updatePlaybackSpeed(this.value)">
                            </div>

                            <!-- Sequence Management -->
                            <div class="btn-group w-100" role="group">
                                <button class="btn btn-sm btn-outline-info" onclick="openSequenceLibrary()">
                                    <i class="bi bi-folder"></i> Library
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteSequence()">
                                    <i class="bi bi-trash"></i> Delete
                                </button>
                            </div>
                        </div>

                        <hr>

                        <!-- Gamepad Controller Section -->
                        <h6>Gamepad Controller</h6>
                        <div class="mb-3">
                            <div id="gamepadStatus" class="alert alert-sm mb-2" style="font-size: 0.85rem; padding: 0.5rem;">
                                <i class="bi bi-controller"></i> <span id="gamepadStatusText">No gamepad detected</span>
                            </div>
                            <div class="form-check form-switch mb-2">
                                <input class="form-check-input" type="checkbox" id="gamepadEnabled">
                                <label class="form-check-label" for="gamepadEnabled">
                                    Enable Gamepad Control
                                </label>
                            </div>
                            <div id="gamepadControls" style="display: none;">
                                <small class="text-muted">
                                    <strong>Controls:</strong><br>
                                    â€¢ Left Stick: Velocity Control<br>
                                    â€¢ A: Stop | B: Zero Position<br>
                                    â€¢ X: Play Sequence | Y: Record<br>
                                    â€¢ Start: Emergency Stop<br>
                                    â€¢ D-Pad: Adjust Presets<br>
                                    â€¢ Triggers: Fine Velocity
                                </small>
                            </div>
                        </div>

                        </div>

                        <hr>

                        <!-- Joystick Position Control -->
                        <div id="joystickControls" class="control-section" style="display: none;">
                        <h6>Joystick Control</h6>
                        <div class="mb-3">
                            <canvas id="joystickCanvas" width="280" height="280"></canvas>
                            <div class="text-center mt-2">
                                <small class="text-muted">
                                    Angle: <span id="joystickAngle">0.0</span>Â°
                                    | Position: <span id="joystickPosition">0.000</span> turns
                                </small>
                            </div>
                            <div class="form-check mt-2">
                                <input class="form-check-input" type="checkbox" id="joystickHoldPosition" checked>
                                <label class="form-check-label" for="joystickHoldPosition">
                                    Hold position on release
                                </label>
                            </div>
                        </div>
                        </div>

                        <hr>

                        <!-- Rotation Control -->
                        <div id="rotationControls" class="control-section" style="display: none;">
                        <h6>Rotation Control</h6>
                        <div id="rotationKnobContainer" class="mb-3">
                            <!-- SVG knob will be created by JavaScript -->
                        </div>
                        <div class="text-center mb-2">
                            <div><strong>Position:</strong> <span id="rotationDegrees">0</span>Â°
                                 (<span id="rotationTurns">0.000</span> turns)</div>
                            <div><small class="text-muted">Rotations: <span id="rotationCount">0</span></small></div>
                        </div>
                        <button class="btn btn-sm btn-warning w-100 mb-2" onclick="setRotationZero()">
                            Set Current as Zero
                        </button>
                        <button class="btn btn-sm btn-secondary w-100" onclick="resetRotationToZero()">
                            Return to Zero
                        </button>
                        </div>

                        <hr>

                        <!-- IK Control -->
                        <div id="ikControls" class="control-section" style="display: none;">
                        <h6>Inverse Kinematics Control</h6>

                        <!-- Config Selection -->
                        <div class="mb-3">
                            <label class="form-label">Robot Configuration:</label>
                            <select id="robotConfigSelect" class="form-select form-select-sm">
                                <option value="single">Single Motor (Current)</option>
                                <option value="2dof">2-DOF Test</option>
                                <option value="3dof">3-DOF Test (Phase 2)</option>
                                <option value="6dof">6-DOF Full Arm (Phase 3)</option>
                            </select>
                            <small class="text-muted">Select robot configuration and upload appropriate Arduino sketch</small>
                        </div>

                        <!-- Joint Controls (always visible) -->
                        <div id="jointControls" class="mb-3">
                            <label class="form-label">Joint Angles:</label>
                            <div id="jointSliders">
                                <!-- Dynamically generated based on config -->
                                <div class="mb-2">
                                    <label>J0: <span id="joint0Value">0.000</span> rad</label>
                                    <input type="range" class="form-range form-range-sm" id="joint0Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                                <div class="mb-2">
                                    <label>J1: <span id="joint1Value">0.000</span> rad</label>
                                    <input type="range" class="form-range form-range-sm" id="joint1Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                                <div class="mb-2" id="joint2Container" style="display: none;">
                                    <label>J2: <span id="joint2Value">0.000</span> rad</label>
                                    <input type="range" class="form-range form-range-sm" id="joint2Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                            </div>
                            <button class="btn btn-primary btn-sm w-100" onclick="setJointAngles()">
                                Set Joint Angles
                            </button>
                        </div>

                        <!-- Cartesian Controls (for multi-motor configs, Phase 2) -->
                        <div id="cartesianControls" style="display: none;">
                            <label class="form-label">Cartesian Target Position:</label>
                            <div class="mb-2">
                                <label>X: <span id="targetX">0.300</span> m</label>
                                <input type="range" class="form-range form-range-sm" id="xSlider"
                                       min="-0.6" max="0.6" step="0.01" value="0.3">
                            </div>
                            <div class="mb-2">
                                <label>Y: <span id="targetY">0.000</span> m</label>
                                <input type="range" class="form-range form-range-sm" id="ySlider"
                                       min="-0.6" max="0.6" step="0.01" value="0.0">
                            </div>
                            <div class="mb-2">
                                <label>Z: <span id="targetZ">0.400</span> m</label>
                                <input type="range" class="form-range form-range-sm" id="zSlider"
                                       min="0.0" max="0.8" step="0.01" value="0.4">
                            </div>
                            <button class="btn btn-success btn-sm w-100 mb-2" onclick="moveToCartesianTarget()">
                                Move to Cartesian Target
                            </button>
                            <div class="text-center">
                                <small>IK Status: <span id="ikStatus" class="badge bg-secondary">Phase 2</span></small>
                            </div>
                        </div>

                        <!-- 2D Robot Arm Visualization -->
                        <div class="mt-3">
                            <label class="form-label">Robot Arm Visualizer:</label>
                            <div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 5px; background-color: #f8f9fa;">
                                <canvas id="robotCanvas" width="280" height="280" style="display: block; margin: 0 auto;"></canvas>
                            </div>
                            <div class="mt-2 text-center">
                                <small id="endEffectorPos" class="text-muted">End Effector: (0.000, 0.000) m</small>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Display Panel -->
            <div class="col-md-8">
                <!-- Current Values -->
                <div class="card">
                    <div class="card-header bg-success text-white">
                        <h5>Current Status</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body">
                                        <h6 class="card-title">Position</h6>
                                        <div class="value-display text-primary" id="currentPosition">0.000</div>
                                        <p class="text-center text-muted">turns</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body">
                                        <h6 class="card-title">Velocity</h6>
                                        <div class="value-display text-success" id="currentVelocity">0.000</div>
                                        <p class="text-center text-muted">turns/sec</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Position Graph -->
                <div class="card">
                    <div class="card-header bg-info text-white">
                        <h5>Position History</h5>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="positionChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Velocity Graph -->
                <div class="card">
                    <div class="card-header bg-warning text-dark">
                        <h5>Velocity History</h5>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="velocityChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log Messages -->
        <div class="card">
            <div class="card-header bg-secondary text-white">
                <h5>System Log</h5>
            </div>
            <div class="card-body">
                <div id="logMessages" style="height: 150px; overflow-y: scroll; font-family: monospace; font-size: 0.9rem;">
                </div>
            </div>
        </div>
    </div>

    <!-- Preset Manager Modal -->
    <div class="modal fade" id="presetManagerModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Manage Position Presets</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="presetManagerList">
                        <!-- Dynamically populated list -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Waypoint Builder Modal -->
    <div class="modal fade" id="waypointBuilderModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Create Waypoint Sequence</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">Waypoint Name</label>
                        <input type="text" class="form-control" id="waypointName" placeholder="e.g., Calibration Sequence">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Positions (turns)</label>
                        <div id="waypointPositionsList" class="mb-2">
                            <!-- Dynamically added position inputs -->
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addWaypointPosition()">
                            + Add Position
                        </button>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Pause Duration (ms)</label>
                        <input type="number" class="form-control" id="waypointPauseDuration" value="1000" min="0" step="100">
                    </div>
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="waypointLoop">
                        <label class="form-check-label" for="waypointLoop">Loop sequence</label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveWaypoint()">Save Waypoint</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Modal -->
    <div class="modal fade" id="shortcutHelpModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Keyboard Shortcuts</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <strong>Note:</strong> Keyboard shortcuts work when not typing in input fields.
                    </div>
                    <div id="shortcutHelpContent">
                        <!-- Dynamically populated by KeyboardShortcutManager -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="keyboardShortcutManager.toggle(); updateShortcutsToggleUI();">
                        <span id="toggleShortcutsText">Disable Shortcuts</span>
                    </button>
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Calibration Results Modal -->
    <div class="modal fade" id="calibrationResultsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Calibration Results</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="calibrationResultsContent">
                        <!-- Dynamically populated by CalibrationExecutor -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="applyCalibrationBtn" onclick="applyCalibrationResults()">
                        Apply Recommended Scale Factor
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Sequence Library Modal -->
    <div class="modal fade" id="sequenceLibraryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Sequence Library</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="sequenceLibraryList">
                        <!-- Dynamically populated sequence list -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Socket.IO connection
        const socket = io();

        // Position scaling factor (to compensate for ODrive encoder config)
        let positionScaleFactor = 10.0;  // Default 10x to fix current 10:1 ratio

        function updateScaleFactorDisplay(value) {
            positionScaleFactor = parseFloat(value);
            document.getElementById('scaleFactorValue').textContent = value;
            localStorage.setItem('positionScaleFactor', value);  // Persist setting
            addLog(`Position scale factor set to ${value}x`, 'info');
        }

        // Chart.js setup
        const maxDataPoints = 100;
        let positionData = [];
        let velocityData = [];
        let timeLabels = [];

        // Position Chart
        const positionCtx = document.getElementById('positionChart').getContext('2d');
        const positionChart = new Chart(positionCtx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [{
                    label: 'Position (turns)',
                    data: positionData,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Position (turns)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    }
                },
                animation: false
            }
        });

        // Velocity Chart
        const velocityCtx = document.getElementById('velocityChart').getContext('2d');
        const velocityChart = new Chart(velocityCtx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [{
                    label: 'Velocity (turns/sec)',
                    data: velocityData,
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Velocity (turns/sec)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    }
                },
                animation: false
            }
        });

        // ========== PRESET MANAGER CLASS ==========
        class PresetManager {
            constructor() {
                this.storageKey = 'odrive_position_presets';
                this.data = this.loadFromStorage();
                this.maxPresets = 10;
                this.availableColors = ['#0d6efd', '#198754', '#dc3545', '#ffc107',
                                        '#0dcaf0', '#6f42c1', '#fd7e14', '#20c997'];
            }

            loadFromStorage() {
                const stored = localStorage.getItem(this.storageKey);
                if (stored) {
                    try {
                        return JSON.parse(stored);
                    } catch (e) {
                        console.error('Failed to parse presets:', e);
                    }
                }
                return { version: 1, presets: [], waypoints: [] };
            }

            saveToStorage() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.data));
            }

            addPreset(name, position, hotkey = null) {
                if (this.data.presets.length >= this.maxPresets) {
                    throw new Error('Maximum 10 presets allowed');
                }

                const preset = {
                    id: `preset_${Date.now()}`,
                    name: name,
                    position: position,
                    color: this.getNextColor(),
                    hotkey: hotkey || this.getNextAvailableHotkey(),
                    created: Date.now(),
                    lastUsed: Date.now()
                };

                this.data.presets.push(preset);
                this.saveToStorage();
                return preset;
            }

            removePreset(id) {
                this.data.presets = this.data.presets.filter(p => p.id !== id);
                this.saveToStorage();
            }

            updatePreset(id, updates) {
                const preset = this.data.presets.find(p => p.id === id);
                if (preset) {
                    Object.assign(preset, updates);
                    this.saveToStorage();
                }
            }

            goToPreset(id) {
                const preset = this.data.presets.find(p => p.id === id);
                if (preset) {
                    preset.lastUsed = Date.now();
                    this.saveToStorage();
                    return preset.position;
                }
                return null;
            }

            getNextAvailableHotkey() {
                const usedKeys = new Set(this.data.presets.map(p => p.hotkey));
                for (let i = 1; i <= 9; i++) {
                    if (!usedKeys.has(String(i))) return String(i);
                }
                if (!usedKeys.has('0')) return '0';
                return null;  // All hotkeys used
            }

            getNextColor() {
                const usedColors = new Set(this.data.presets.map(p => p.color));
                for (const color of this.availableColors) {
                    if (!usedColors.has(color)) return color;
                }
                return this.availableColors[0];  // Fallback
            }

            // Waypoint methods
            addWaypoint(name, positions, pauseDuration = 1000, loop = false) {
                const waypoint = {
                    id: `waypoint_${Date.now()}`,
                    name: name,
                    positions: positions,
                    pauseDuration: pauseDuration,
                    loop: loop,
                    created: Date.now()
                };
                this.data.waypoints.push(waypoint);
                this.saveToStorage();
                return waypoint;
            }

            removeWaypoint(id) {
                this.data.waypoints = this.data.waypoints.filter(w => w.id !== id);
                this.saveToStorage();
            }
        }

        // ========== WAYPOINT EXECUTOR CLASS ==========
        class WaypointExecutor {
            constructor(socketConnection, presetManager) {
                this.socket = socketConnection;
                this.presetManager = presetManager;
                this.isExecuting = false;
                this.currentWaypointId = null;
                this.currentStep = 0;
                this.loopCount = 0;
            }

            async executeWaypoint(waypointId) {
                if (this.isExecuting) {
                    throw new Error('Waypoint execution already in progress');
                }

                const waypoint = this.presetManager.data.waypoints.find(w => w.id === waypointId);
                if (!waypoint) {
                    throw new Error('Waypoint not found');
                }

                this.isExecuting = true;
                this.currentWaypointId = waypointId;
                this.currentStep = 0;

                // Disable execute button, enable stop button
                document.getElementById('executeWaypointBtn').disabled = true;
                document.getElementById('stopWaypointBtn').disabled = false;

                do {
                    for (let i = 0; i < waypoint.positions.length; i++) {
                        if (!this.isExecuting) break;  // Stopped externally

                        this.currentStep = i;
                        const scaledPosition = waypoint.positions[i] * positionScaleFactor;
                        this.socket.emit('set_position', { position: scaledPosition });

                        addLog(`Waypoint step ${i + 1}/${waypoint.positions.length}: Moving to ${waypoint.positions[i].toFixed(3)} turns`, 'info');

                        if (i < waypoint.positions.length - 1) {
                            await this.sleep(waypoint.pauseDuration);
                        }
                    }
                    this.loopCount++;
                } while (waypoint.loop && this.isExecuting);

                this.stop();
                addLog(`Waypoint "${waypoint.name}" completed`, 'success');
            }

            stop() {
                this.isExecuting = false;
                this.currentWaypointId = null;
                this.currentStep = 0;
                this.loopCount = 0;

                // Re-enable execute button, disable stop button
                document.getElementById('executeWaypointBtn').disabled = false;
                document.getElementById('stopWaypointBtn').disabled = true;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize preset manager and waypoint executor
        const presetManager = new PresetManager();
        const waypointExecutor = new WaypointExecutor(socket, presetManager);

        // ========== AUTO-CALIBRATION EXECUTOR ==========
        class CalibrationExecutor {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isCalibrating = false;
                this.currentStep = 0;
                this.steps = [
                    { name: 'Move to Zero', progress: 10 },
                    { name: 'Wait for Settle', progress: 25 },
                    { name: 'Rotate 1 Turn', progress: 50 },
                    { name: 'Wait for Settle', progress: 75 },
                    { name: 'Return to Zero', progress: 90 },
                    { name: 'Calculate Results', progress: 100 }
                ];
                this.calibrationData = {
                    startPosition: 0,
                    afterRotationPosition: 0,
                    endPosition: 0,
                    commandedRotation: 1.0,
                    actualRotation: 0,
                    currentScaleFactor: positionScaleFactor,
                    recommendedScaleFactor: 0,
                    error: 0,
                    errorPercentage: 0
                };
            }

            async startCalibration() {
                if (this.isCalibrating) {
                    throw new Error('Calibration already in progress');
                }

                this.isCalibrating = true;
                this.currentStep = 0;

                const progressDiv = document.getElementById('calibrationProgress');
                const startBtn = document.getElementById('startCalibrationBtn');

                progressDiv.style.display = 'block';
                startBtn.disabled = true;

                try {
                    // Step 1: Move to zero position
                    await this.executeStep(0, async () => {
                        // Get current position first
                        const currentPos = parseFloat(document.getElementById('currentPosition').textContent);
                        this.calibrationData.startPosition = currentPos;

                        // Move to zero
                        const scaledPosition = 0 * positionScaleFactor;
                        this.socket.emit('set_position', { position: scaledPosition });
                        await this.wait(2000); // Wait 2 seconds for movement
                    });

                    // Step 2: Wait for settle
                    await this.executeStep(1, async () => {
                        await this.wait(1000);
                        // Record position after settling at zero
                        this.calibrationData.startPosition = parseFloat(document.getElementById('currentPosition').textContent);
                    });

                    // Step 3: Rotate exactly 1 turn
                    await this.executeStep(2, async () => {
                        const scaledPosition = this.calibrationData.commandedRotation * positionScaleFactor;
                        this.socket.emit('set_position', { position: scaledPosition });
                        await this.wait(3000); // Wait 3 seconds for full rotation
                    });

                    // Step 4: Wait for settle
                    await this.executeStep(3, async () => {
                        await this.wait(1000);
                        // Record position after rotation
                        this.calibrationData.afterRotationPosition = parseFloat(document.getElementById('currentPosition').textContent);
                    });

                    // Step 5: Return to zero
                    await this.executeStep(4, async () => {
                        const scaledPosition = 0 * positionScaleFactor;
                        this.socket.emit('set_position', { position: scaledPosition });
                        await this.wait(3000);
                    });

                    // Step 6: Calculate results
                    await this.executeStep(5, async () => {
                        this.calibrationData.endPosition = parseFloat(document.getElementById('currentPosition').textContent);
                        this.calculateResults();
                    });

                    // Show results modal
                    this.displayResults();

                } catch (error) {
                    addLog(`Calibration error: ${error.message}`, 'danger');
                    this.updateStatus(`Error: ${error.message}`, 100);
                } finally {
                    this.isCalibrating = false;
                    startBtn.disabled = false;

                    // Hide progress after 2 seconds
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 2000);
                }
            }

            async executeStep(stepIndex, action) {
                this.currentStep = stepIndex;
                const step = this.steps[stepIndex];

                this.updateStatus(step.name, step.progress);
                await action();
            }

            updateStatus(message, progress) {
                const statusEl = document.getElementById('calibrationStatus');
                const progressBar = document.getElementById('calibrationProgressBar');

                if (statusEl) statusEl.textContent = message;
                if (progressBar) progressBar.style.width = `${progress}%`;
            }

            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            calculateResults() {
                const { startPosition, afterRotationPosition, commandedRotation, currentScaleFactor } = this.calibrationData;

                // Calculate actual rotation (encoder feedback)
                const actualRotation = afterRotationPosition - startPosition;
                this.calibrationData.actualRotation = actualRotation;

                // Calculate error
                this.calibrationData.error = commandedRotation - actualRotation;
                this.calibrationData.errorPercentage = (this.calibrationData.error / commandedRotation) * 100;

                // Calculate recommended scale factor
                // If actual rotation is less than commanded, we need a smaller scale factor
                // If actual rotation is more than commanded, we need a larger scale factor
                // recommended = current * (commanded / actual)
                if (actualRotation !== 0) {
                    this.calibrationData.recommendedScaleFactor = currentScaleFactor * (commandedRotation / actualRotation);
                } else {
                    this.calibrationData.recommendedScaleFactor = currentScaleFactor;
                }
            }

            displayResults() {
                const { startPosition, afterRotationPosition, endPosition, commandedRotation,
                        actualRotation, currentScaleFactor, recommendedScaleFactor,
                        error, errorPercentage } = this.calibrationData;

                const tolerance = 0.01; // 1% tolerance
                const isAccurate = Math.abs(error) <= tolerance;

                let resultClass = isAccurate ? 'success' : 'warning';
                let resultIcon = isAccurate ? 'check-circle-fill' : 'exclamation-triangle-fill';
                let resultMessage = isAccurate
                    ? 'Calibration is accurate! Your current scale factor is correct.'
                    : 'Calibration shows a position error. Consider applying the recommended scale factor.';

                const html = `
                    <div class="alert alert-${resultClass}">
                        <i class="bi bi-${resultIcon}"></i> <strong>${resultMessage}</strong>
                    </div>

                    <h6>Calibration Data:</h6>
                    <table class="table table-sm">
                        <tr>
                            <td><strong>Start Position:</strong></td>
                            <td>${startPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>After 1 Turn Command:</strong></td>
                            <td>${afterRotationPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Return to Zero:</strong></td>
                            <td>${endPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Commanded Rotation:</strong></td>
                            <td>${commandedRotation.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Actual Rotation:</strong></td>
                            <td>${actualRotation.toFixed(4)} turns</td>
                        </tr>
                        <tr class="${Math.abs(error) > tolerance ? 'table-warning' : ''}">
                            <td><strong>Position Error:</strong></td>
                            <td>${error.toFixed(4)} turns (${errorPercentage.toFixed(2)}%)</td>
                        </tr>
                    </table>

                    <h6>Scale Factor:</h6>
                    <table class="table table-sm">
                        <tr>
                            <td><strong>Current Scale Factor:</strong></td>
                            <td>${currentScaleFactor.toFixed(2)}x</td>
                        </tr>
                        <tr class="${!isAccurate ? 'table-info' : ''}">
                            <td><strong>Recommended Scale Factor:</strong></td>
                            <td>${recommendedScaleFactor.toFixed(2)}x</td>
                        </tr>
                    </table>

                    ${!isAccurate ? `
                        <div class="alert alert-info mt-3">
                            <strong>Recommendation:</strong> Click "Apply Recommended Scale Factor" to update the scale factor to ${recommendedScaleFactor.toFixed(2)}x.
                            This should improve position accuracy.
                        </div>
                    ` : `
                        <div class="alert alert-success mt-3">
                            <strong>No action needed.</strong> Your position tracking is already accurate within ${(tolerance * 100).toFixed(1)}% tolerance.
                        </div>
                    `}
                `;

                document.getElementById('calibrationResultsContent').innerHTML = html;

                // Show/hide apply button based on accuracy
                const applyBtn = document.getElementById('applyCalibrationBtn');
                if (applyBtn) {
                    applyBtn.style.display = isAccurate ? 'none' : 'inline-block';
                }

                const modal = new bootstrap.Modal(document.getElementById('calibrationResultsModal'));
                modal.show();

                addLog('Calibration complete', 'success');
            }

            getRecommendedScaleFactor() {
                return this.calibrationData.recommendedScaleFactor;
            }
        }

        // Initialize calibration executor
        const calibrationExecutor = new CalibrationExecutor(socket);

        // ========== SESSION RECORDER & PLAYBACK ==========
        class SessionRecorder {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isRecording = false;
                this.recordingData = [];
                this.startTime = 0;
                this.recordingTimer = null;
                this.sampleRate = 10; // Hz (every 100ms)
            }

            startRecording(sessionName) {
                if (this.isRecording) {
                    throw new Error('Recording already in progress');
                }

                this.isRecording = true;
                this.recordingData = [];
                this.startTime = Date.now();
                this.sessionName = sessionName || `Session_${new Date().toISOString().replace(/[:.]/g, '-')}`;

                // Start recording timer
                this.recordingTimer = setInterval(() => {
                    this.recordDataPoint();
                }, 1000 / this.sampleRate);

                addLog(`Recording started: ${this.sessionName}`, 'info');
            }

            recordDataPoint() {
                if (!this.isRecording) return;

                const currentTime = (Date.now() - this.startTime) / 1000; // seconds
                const position = parseFloat(document.getElementById('currentPosition').textContent) || 0;
                const velocity = parseFloat(document.getElementById('currentVelocity').textContent) || 0;

                this.recordingData.push({
                    timestamp: currentTime,
                    position: position,
                    velocity: velocity
                });
            }

            stopRecording() {
                if (!this.isRecording) return null;

                this.isRecording = false;
                clearInterval(this.recordingTimer);

                const duration = (Date.now() - this.startTime) / 1000;

                const sessionData = {
                    session_metadata: {
                        name: this.sessionName,
                        start_time: new Date(this.startTime).toISOString(),
                        duration_seconds: duration,
                        sample_rate_hz: this.sampleRate,
                        data_points_count: this.recordingData.length
                    },
                    data_points: this.recordingData
                };

                addLog(`Recording stopped: ${duration.toFixed(1)}s, ${this.recordingData.length} points`, 'success');

                return sessionData;
            }

            getDuration() {
                if (!this.isRecording) return 0;
                return (Date.now() - this.startTime) / 1000;
            }
        }

        class SessionPlayback {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isPlaying = false;
                this.isPaused = false;
                this.sessionData = null;
                this.currentIndex = 0;
                this.playbackSpeed = 1.0;
                this.playbackTimer = null;
                this.startTime = 0;
                this.pauseTime = 0;
                this.pausedDuration = 0;
            }

            loadSession(sessionData) {
                if (this.isPlaying) {
                    throw new Error('Cannot load session while playing');
                }

                this.sessionData = sessionData;
                this.currentIndex = 0;
                addLog(`Session loaded: ${sessionData.session_metadata.name}`, 'info');
            }

            play() {
                if (!this.sessionData) {
                    throw new Error('No session loaded');
                }

                if (this.isPaused) {
                    // Resume from pause
                    this.isPaused = false;
                    this.pausedDuration += Date.now() - this.pauseTime;
                    this.scheduleNextPoint();
                    addLog('Playback resumed', 'info');
                    return;
                }

                if (this.isPlaying) {
                    addLog('Already playing', 'warning');
                    return;
                }

                this.isPlaying = true;
                this.currentIndex = 0;
                this.startTime = Date.now();
                this.pausedDuration = 0;

                addLog(`Playback started: ${this.sessionData.session_metadata.name}`, 'info');
                this.scheduleNextPoint();
            }

            pause() {
                if (!this.isPlaying || this.isPaused) return;

                this.isPaused = true;
                this.pauseTime = Date.now();
                clearTimeout(this.playbackTimer);
                addLog('Playback paused', 'info');
            }

            stop() {
                if (!this.isPlaying) return;

                this.isPlaying = false;
                this.isPaused = false;
                this.currentIndex = 0;
                clearTimeout(this.playbackTimer);

                // Stop motor
                this.socket.emit('stop');
                addLog('Playback stopped', 'info');
            }

            scheduleNextPoint() {
                if (!this.isPlaying || this.isPaused) return;

                if (this.currentIndex >= this.sessionData.data_points.length) {
                    this.stop();
                    addLog('Playback complete', 'success');
                    return;
                }

                const dataPoint = this.sessionData.data_points[this.currentIndex];
                const elapsedTime = (Date.now() - this.startTime - this.pausedDuration) / 1000;
                const targetTime = dataPoint.timestamp / this.playbackSpeed;

                if (elapsedTime >= targetTime) {
                    // Execute this point
                    const scaledPosition = dataPoint.position * positionScaleFactor;
                    this.socket.emit('set_position', { position: scaledPosition });

                    this.currentIndex++;

                    // Update progress UI
                    const progress = (this.currentIndex / this.sessionData.data_points.length) * 100;
                    updatePlaybackProgress(progress, elapsedTime * this.playbackSpeed);

                    // Schedule next point immediately
                    this.playbackTimer = setTimeout(() => this.scheduleNextPoint(), 0);
                } else {
                    // Wait until target time
                    const waitTime = (targetTime - elapsedTime) * 1000;
                    this.playbackTimer = setTimeout(() => this.scheduleNextPoint(), waitTime);
                }
            }

            setSpeed(speed) {
                this.playbackSpeed = Math.max(0.1, Math.min(3.0, speed));

                // If currently playing, restart timing from current point
                if (this.isPlaying && !this.isPaused) {
                    this.startTime = Date.now();
                    this.pausedDuration = 0;
                    // Adjust to current timestamp
                    if (this.currentIndex > 0) {
                        const currentDataPoint = this.sessionData.data_points[this.currentIndex - 1];
                        this.startTime -= (currentDataPoint.timestamp / this.playbackSpeed) * 1000;
                    }
                }
            }

            getProgress() {
                if (!this.sessionData) return 0;
                return (this.currentIndex / this.sessionData.data_points.length) * 100;
            }

            getCurrentTime() {
                if (!this.sessionData || this.currentIndex === 0) return 0;
                const dataPoint = this.sessionData.data_points[this.currentIndex - 1];
                return dataPoint.timestamp;
            }

            getDuration() {
                if (!this.sessionData) return 0;
                return this.sessionData.session_metadata.duration_seconds;
            }
        }

        // Initialize session recorder and playback
        const sessionRecorder = new SessionRecorder(socket);
        const sessionPlayback = new SessionPlayback(socket);

        // ========== GAMEPAD CONTROLLER ==========
        class GamepadController {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.enabled = false;
                this.gamepad = null;
                this.pollInterval = null;
                this.deadzone = 0.15;
                this.currentVelocity = 0;
                this.maxVelocity = 10.0;
                this.lastButtonStates = {};

                // Button mappings (standard gamepad layout)
                this.buttonMap = {
                    0: 'A',      // Stop
                    1: 'B',      // Zero position
                    2: 'X',      // Play sequence
                    3: 'Y',      // Record
                    9: 'Start',  // Emergency stop
                    12: 'Up',    // D-pad up
                    13: 'Down',  // D-pad down
                    14: 'Left',  // D-pad left
                    15: 'Right'  // D-pad right
                };

                this.init();
            }

            init() {
                // Listen for gamepad connection events
                window.addEventListener('gamepadconnected', (e) => this.onGamepadConnected(e));
                window.addEventListener('gamepaddisconnected', (e) => this.onGamepadDisconnected(e));

                // Check for already connected gamepads
                this.checkForGamepads();

                // Setup enable checkbox
                const enableCheckbox = document.getElementById('gamepadEnabled');
                if (enableCheckbox) {
                    enableCheckbox.addEventListener('change', (e) => {
                        this.setEnabled(e.target.checked);
                    });
                }
            }

            checkForGamepads() {
                const gamepads = navigator.getGamepads();
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        this.onGamepadConnected({ gamepad: gamepads[i] });
                        break;
                    }
                }
            }

            onGamepadConnected(event) {
                this.gamepad = event.gamepad;
                this.updateStatus(`${this.gamepad.id} connected`, 'success');
                document.getElementById('gamepadControls').style.display = 'block';
                addLog(`Gamepad connected: ${this.gamepad.id}`, 'info');
            }

            onGamepadDisconnected(event) {
                this.updateStatus('No gamepad detected', 'warning');
                document.getElementById('gamepadControls').style.display = 'none';
                this.stopPolling();
                this.gamepad = null;
                addLog('Gamepad disconnected', 'warning');
            }

            updateStatus(text, type = 'info') {
                const statusDiv = document.getElementById('gamepadStatus');
                const statusText = document.getElementById('gamepadStatusText');

                if (statusText) statusText.textContent = text;

                if (statusDiv) {
                    statusDiv.className = 'alert alert-sm mb-2';
                    if (type === 'success') statusDiv.classList.add('alert-success');
                    else if (type === 'warning') statusDiv.classList.add('alert-warning');
                    else statusDiv.classList.add('alert-info');
                }
            }

            setEnabled(enabled) {
                this.enabled = enabled;

                if (enabled && this.gamepad) {
                    this.startPolling();
                    addLog('Gamepad control enabled', 'success');
                } else {
                    this.stopPolling();
                    addLog('Gamepad control disabled', 'info');
                }
            }

            startPolling() {
                if (this.pollInterval) return;

                this.pollInterval = setInterval(() => {
                    this.poll();
                }, 50); // 20Hz polling
            }

            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                    // Stop motor when disabling
                    this.socket.emit('set_velocity', { velocity: 0 });
                }
            }

            poll() {
                if (!this.enabled || !this.gamepad) return;

                // Get fresh gamepad state
                const gamepads = navigator.getGamepads();
                this.gamepad = gamepads[this.gamepad.index];

                if (!this.gamepad) return;

                // Process analog sticks
                this.processAnalogInputs();

                // Process buttons
                this.processButtons();
            }

            processAnalogInputs() {
                // Left stick Y axis (index 1) - velocity control
                const leftY = this.gamepad.axes[1] || 0;

                // Apply deadzone
                const velocity = Math.abs(leftY) > this.deadzone
                    ? -leftY * this.maxVelocity  // Invert Y axis (up = positive)
                    : 0;

                // Only send if velocity changed significantly
                if (Math.abs(velocity - this.currentVelocity) > 0.1) {
                    this.currentVelocity = velocity;
                    this.socket.emit('set_velocity', { velocity: velocity });
                }

                // Triggers - fine velocity adjust
                const leftTrigger = this.gamepad.buttons[6]?.value || 0;
                const rightTrigger = this.gamepad.buttons[7]?.value || 0;

                if (leftTrigger > 0.1 || rightTrigger > 0.1) {
                    const fineVelocity = (rightTrigger - leftTrigger) * 2.0; // Max Â±2.0
                    this.socket.emit('set_velocity', { velocity: fineVelocity });
                }
            }

            processButtons() {
                this.gamepad.buttons.forEach((button, index) => {
                    const pressed = button.pressed;
                    const wasPressed = this.lastButtonStates[index] || false;

                    // Detect button press (not held)
                    if (pressed && !wasPressed) {
                        this.handleButtonPress(index);
                    }

                    this.lastButtonStates[index] = pressed;
                });
            }

            handleButtonPress(buttonIndex) {
                const buttonName = this.buttonMap[buttonIndex];

                switch (buttonIndex) {
                    case 0: // A - Stop
                        this.socket.emit('stop');
                        addLog('Gamepad: Stop', 'info');
                        break;

                    case 1: // B - Zero position
                        this.socket.emit('set_position', { position: 0 });
                        addLog('Gamepad: Go to zero', 'info');
                        break;

                    case 2: // X - Play sequence
                        if (document.getElementById('sequenceSelect').value) {
                            playSequence();
                        }
                        break;

                    case 3: // Y - Record toggle
                        if (sessionRecorder.isRecording) {
                            stopRecording();
                        } else {
                            startRecording();
                        }
                        break;

                    case 9: // Start - Emergency stop
                        emergencyStop();
                        break;

                    case 12: // D-pad Up - Next preset
                    case 13: // D-pad Down - Previous preset
                    case 14: // D-pad Left
                    case 15: // D-pad Right
                        this.handleDPad(buttonIndex);
                        break;
                }
            }

            handleDPad(buttonIndex) {
                const presets = presetManager.data.presets;
                if (presets.length === 0) return;

                let currentIndex = -1;
                const currentPos = parseFloat(document.getElementById('currentPosition').textContent);

                // Find closest preset
                presets.forEach((preset, index) => {
                    if (Math.abs(preset.position - currentPos) < 0.1) {
                        currentIndex = index;
                    }
                });

                let newIndex = currentIndex;

                if (buttonIndex === 12) { // Up
                    newIndex = (currentIndex + 1) % presets.length;
                } else if (buttonIndex === 13) { // Down
                    newIndex = currentIndex > 0 ? currentIndex - 1 : presets.length - 1;
                }

                if (newIndex >= 0 && newIndex < presets.length) {
                    goToPreset(presets[newIndex].id);
                }
            }
        }

        // Initialize gamepad controller
        const gamepadController = new GamepadController(socket);

        // ========== KEYBOARD SHORTCUTS MANAGER ==========
        class KeyboardShortcutManager {
            constructor(config) {
                this.config = config;
                this.enabled = this.loadEnabledState();
                this.actionMap = this.buildActionMap();
                this.pressedKeys = new Set();

                this.init();
            }

            loadEnabledState() {
                const stored = localStorage.getItem('keyboard_shortcuts_enabled');
                return stored !== null ? JSON.parse(stored) : true;
            }

            saveEnabledState() {
                localStorage.setItem('keyboard_shortcuts_enabled', JSON.stringify(this.enabled));
            }

            buildActionMap() {
                return {
                    emergencyStop: () => emergencyStop(),
                    increaseVelocity: (params) => {
                        adjustVelocity(params.delta);
                        applyVelocity();
                    },
                    decreaseVelocity: (params) => {
                        adjustVelocity(-params.delta);
                        applyVelocity();
                    },
                    goToPreset: (params) => {
                        const preset = presetManager.data.presets.find(p => p.hotkey === params.hotkey);
                        if (preset) {
                            goToPreset(preset.id);
                        }
                    },
                    switchMode: (params) => {
                        const modeRadio = document.getElementById(params.mode + 'Mode');
                        if (modeRadio) {
                            modeRadio.checked = true;
                            switchControlMode(params.mode);
                        }
                    },
                    saveCurrentAsPreset: () => saveCurrentAsPreset(),
                    goToHome: () => {
                        socket.emit('set_position', { position: 0 });
                        addLog('Going to home position (0.0)', 'info');
                    },
                    showShortcutHelp: () => this.showHelpModal()
                };
            }

            init() {
                document.addEventListener('keydown', this.handleKeyDown.bind(this), true);
                document.addEventListener('keyup', this.handleKeyUp.bind(this), true);
                addLog('Keyboard shortcuts enabled. Press ? for help.', 'info');
            }

            handleKeyDown(event) {
                if (this.isInputElement(event.target)) {
                    return;
                }

                if (!this.enabled) {
                    return;
                }

                const keyCode = this.getKeyCode(event);
                const binding = this.config.bindings[keyCode];

                if (!binding) {
                    return;
                }

                if (binding.requireCtrl && !event.ctrlKey) return;
                if (binding.requireShift && !event.shiftKey) return;
                if (binding.requireAlt && !event.altKey) return;

                if (binding.preventDefault) {
                    event.preventDefault();
                    event.stopPropagation();
                }

                if (!binding.repeat && this.pressedKeys.has(keyCode)) {
                    return;
                }

                this.pressedKeys.add(keyCode);

                try {
                    const action = this.actionMap[binding.action];
                    if (action) {
                        action(binding.params || {});
                    } else {
                        console.warn(`Unknown action: ${binding.action}`);
                    }
                } catch (error) {
                    console.error(`Error executing shortcut ${keyCode}:`, error);
                    addLog(`Shortcut error: ${error.message}`, 'danger');
                }
            }

            handleKeyUp(event) {
                const keyCode = this.getKeyCode(event);
                this.pressedKeys.delete(keyCode);
            }

            getKeyCode(event) {
                if (event.key === 'ArrowUp') return 'arrowUp';
                if (event.key === 'ArrowDown') return 'arrowDown';
                if (event.key === 'ArrowLeft') return 'arrowLeft';
                if (event.key === 'ArrowRight') return 'arrowRight';
                if (event.key === ' ' || event.code === 'Space') return 'space';
                if (event.key === '?' || (event.key === '/' && event.shiftKey)) return 'keySlash';

                if (/^Digit[0-9]$/.test(event.code)) return event.code.toLowerCase();
                if (/^Key[A-Z]$/.test(event.code)) return event.code.toLowerCase();

                return event.key.toLowerCase();
            }

            isInputElement(element) {
                const tagName = element.tagName.toLowerCase();
                return (
                    tagName === 'input' ||
                    tagName === 'textarea' ||
                    tagName === 'select' ||
                    element.isContentEditable
                );
            }

            showHelpModal() {
                this.renderHelpContent();
                const modal = new bootstrap.Modal(document.getElementById('shortcutHelpModal'));
                modal.show();
            }

            renderHelpContent() {
                const container = document.getElementById('shortcutHelpContent');

                const categories = {
                    safety: 'Safety Controls',
                    velocity: 'Velocity Control',
                    presets: 'Position Presets',
                    modes: 'Control Modes',
                    navigation: 'Navigation',
                    help: 'Help'
                };

                let html = '';

                for (const [categoryKey, categoryName] of Object.entries(categories)) {
                    const shortcuts = Object.entries(this.config.bindings)
                        .filter(([_, binding]) => binding.category === categoryKey);

                    if (shortcuts.length === 0) continue;

                    html += `<h6 class="mt-3">${categoryName}</h6>`;
                    html += '<table class="table table-sm table-hover">';
                    html += '<thead><tr><th>Key</th><th>Action</th></tr></thead>';
                    html += '<tbody>';

                    for (const [keyCode, binding] of shortcuts) {
                        const keyDisplay = this.formatKeyDisplay(keyCode, binding);
                        html += `<tr><td><kbd>${keyDisplay}</kbd></td><td>${binding.description}</td></tr>`;
                    }

                    html += '</tbody></table>';
                }

                container.innerHTML = html;
            }

            formatKeyDisplay(keyCode, binding) {
                let display = keyCode
                    .replace('arrow', '')
                    .replace('digit', '')
                    .replace('key', '')
                    .toUpperCase();

                if (keyCode === 'arrowUp') display = 'â†‘';
                if (keyCode === 'arrowDown') display = 'â†“';
                if (keyCode === 'arrowLeft') display = 'â†';
                if (keyCode === 'arrowRight') display = 'â†’';
                if (keyCode === 'space') display = 'SPACE';
                if (keyCode === 'keySlash') display = '?';

                if (binding.requireCtrl) display = 'Ctrl + ' + display;
                if (binding.requireShift) display = 'Shift + ' + display;
                if (binding.requireAlt) display = 'Alt + ' + display;

                return display;
            }

            toggle() {
                this.enabled = !this.enabled;
                this.saveEnabledState();
                addLog(`Keyboard shortcuts ${this.enabled ? 'enabled' : 'disabled'}`, 'info');
            }

            isEnabled() {
                return this.enabled;
            }
        }

        // Keyboard shortcut configuration
        const keyboardShortcuts = {
            version: 1,
            enabled: true,
            bindings: {
                space: {
                    action: 'emergencyStop',
                    description: 'Emergency Stop',
                    category: 'safety',
                    preventDefault: true
                },
                arrowUp: {
                    action: 'increaseVelocity',
                    params: { delta: 0.5 },
                    description: 'Increase velocity by 0.5 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowDown: {
                    action: 'decreaseVelocity',
                    params: { delta: 0.5 },
                    description: 'Decrease velocity by 0.5 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowLeft: {
                    action: 'decreaseVelocity',
                    params: { delta: 0.1 },
                    description: 'Fine decrease velocity by 0.1 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowRight: {
                    action: 'increaseVelocity',
                    params: { delta: 0.1 },
                    description: 'Fine increase velocity by 0.1 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                digit1: { action: 'goToPreset', params: { hotkey: '1' }, description: 'Go to preset 1', category: 'presets' },
                digit2: { action: 'goToPreset', params: { hotkey: '2' }, description: 'Go to preset 2', category: 'presets' },
                digit3: { action: 'goToPreset', params: { hotkey: '3' }, description: 'Go to preset 3', category: 'presets' },
                digit4: { action: 'goToPreset', params: { hotkey: '4' }, description: 'Go to preset 4', category: 'presets' },
                digit5: { action: 'goToPreset', params: { hotkey: '5' }, description: 'Go to preset 5', category: 'presets' },
                digit6: { action: 'goToPreset', params: { hotkey: '6' }, description: 'Go to preset 6', category: 'presets' },
                digit7: { action: 'goToPreset', params: { hotkey: '7' }, description: 'Go to preset 7', category: 'presets' },
                digit8: { action: 'goToPreset', params: { hotkey: '8' }, description: 'Go to preset 8', category: 'presets' },
                digit9: { action: 'goToPreset', params: { hotkey: '9' }, description: 'Go to preset 9', category: 'presets' },
                digit0: { action: 'goToPreset', params: { hotkey: '0' }, description: 'Go to preset 0', category: 'presets' },
                keyv: { action: 'switchMode', params: { mode: 'velocity' }, description: 'Switch to Velocity mode', category: 'modes' },
                keyj: { action: 'switchMode', params: { mode: 'joystick' }, description: 'Switch to Joystick mode', category: 'modes' },
                keyr: { action: 'switchMode', params: { mode: 'rotation' }, description: 'Switch to Rotation Knob mode', category: 'modes' },
                keyi: { action: 'switchMode', params: { mode: 'ik' }, description: 'Switch to IK Control mode', category: 'modes' },
                keys: { action: 'saveCurrentAsPreset', description: 'Save current position as preset', category: 'presets', requireCtrl: false },
                keyh: { action: 'goToHome', description: 'Go to home position (0.0)', category: 'navigation' },
                keySlash: { action: 'showShortcutHelp', description: 'Show keyboard shortcuts', category: 'help', requireShift: true }
            }
        };

        // Initialize keyboard shortcuts
        const keyboardShortcutManager = new KeyboardShortcutManager(keyboardShortcuts);

        // Socket.IO event handlers
        socket.on('connect', function() {
            updateConnectionStatus(true);
            addLog('Connected to server', 'success');
        });

        socket.on('disconnect', function() {
            updateConnectionStatus(false);
            addLog('Disconnected from server', 'danger');
        });

        socket.on('feedback', function(data) {
            updateDisplay(data.position, data.velocity);

            // Update current motor position for rotation knob calibration
            currentMotorPosition = data.position;

            // Initialize rotation knob on first feedback (sync with motor position)
            if (!initializedRotationKnob && typeof data.position !== 'undefined') {
                cumulativeRotation = data.position * 360;
                rotationZeroPosition = 0;
                updateRotationKnobDisplay();
                initializedRotationKnob = true;
                addLog('Rotation knob synchronized with motor position', 'success');
            }

            // Update robot visualizer for multi-motor feedback
            if (data.joints && data.joints.length >= 2) {
                // Multi-motor mode - update visualizer with joint angles
                const angles = data.joints.map(j => j.position);
                robotVisualizer.updateJointAngles(angles);
            } else if (typeof data.position !== 'undefined') {
                // Single motor mode - treat as joint 0
                robotVisualizer.updateJointAngles([data.position, 0]);
            }
        });

        socket.on('status', function(data) {
            document.getElementById('motorState').textContent = data.state;
            addLog(`Motor state: ${data.state}`, 'info');
        });

        socket.on('error', function(data) {
            addLog(`Error: ${data.message}`, 'danger');
        });

        socket.on('command_response', function(data) {
            addLog(`${data.command}: ${data.response}`, 'info');
        });

        socket.on('ik_result', function(data) {
            if (data.success) {
                document.getElementById('ikStatus').textContent = 'Success';
                document.getElementById('ikStatus').className = 'badge bg-success';
                addLog(`IK solved: error=${(data.error * 1000).toFixed(2)}mm, joints=[${data.joint_angles.map(a => a.toFixed(3)).join(', ')}]`, 'success');

                // Update visualizer with IK solution
                if (data.joint_angles.length >= 2) {
                    robotVisualizer.updateJointAngles(data.joint_angles);
                }
            } else {
                document.getElementById('ikStatus').textContent = 'Failed';
                document.getElementById('ikStatus').className = 'badge bg-danger';
                addLog(`IK failed: ${(data.error * 1000).toFixed(2)}mm from target`, 'danger');
            }
        });

        socket.on('config', function(data) {
            addLog(`Config: ${data.data}`, 'info');
        });

        // UI Functions
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const text = document.getElementById('connectionText');
            if (connected) {
                indicator.className = 'status-indicator status-connected';
                text.textContent = 'Connected';
            } else {
                indicator.className = 'status-indicator status-disconnected';
                text.textContent = 'Disconnected';
            }
        }

        function updateDisplay(position, velocity) {
            document.getElementById('currentPosition').textContent = position.toFixed(3);
            document.getElementById('currentVelocity').textContent = velocity.toFixed(3);

            // Update charts
            const now = new Date().toLocaleTimeString();
            timeLabels.push(now);
            positionData.push(position);
            velocityData.push(velocity);

            // Keep only last maxDataPoints
            if (timeLabels.length > maxDataPoints) {
                timeLabels.shift();
                positionData.shift();
                velocityData.shift();
            }

            positionChart.update();
            velocityChart.update();
        }

        function addLog(message, type = 'info') {
            const logDiv = document.getElementById('logMessages');
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'danger' ? 'text-danger' :
                              type === 'success' ? 'text-success' :
                              type === 'warning' ? 'text-warning' : 'text-info';
            logDiv.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateVelocityDisplay(value) {
            document.getElementById('velocityValue').textContent = parseFloat(value).toFixed(1);
        }

        function setVelocity(value) {
            document.getElementById('velocitySlider').value = value;
            updateVelocityDisplay(value);
        }

        function adjustVelocity(delta) {
            const slider = document.getElementById('velocitySlider');
            const newValue = parseFloat(slider.value) + delta;
            const clampedValue = Math.max(-10, Math.min(10, newValue));
            setVelocity(clampedValue);
        }

        function applyVelocity() {
            const velocity = parseFloat(document.getElementById('velocitySlider').value);
            socket.emit('set_velocity', { velocity: velocity });
            addLog(`Setting velocity: ${velocity.toFixed(2)} turns/sec`, 'info');
        }

        function emergencyStop() {
            socket.emit('stop');
            setVelocity(0);
            addLog('EMERGENCY STOP activated', 'danger');
        }

        function goToPosition() {
            const position = parseFloat(document.getElementById('positionInput').value);
            if (!isNaN(position)) {
                // Apply scaling factor
                const scaledPosition = position * positionScaleFactor;
                socket.emit('set_position', { position: scaledPosition });
                addLog(`Moving to position: ${position.toFixed(2)} turns (scaled: ${scaledPosition.toFixed(2)})`, 'info');
            }
        }

        function requestConfig() {
            socket.emit('get_config');
        }

        // Request position updates periodically
        setInterval(function() {
            socket.emit('get_position');
        }, 100);

        // Load saved scale factor from localStorage
        window.addEventListener('DOMContentLoaded', function() {
            const saved = localStorage.getItem('positionScaleFactor');
            if (saved) {
                positionScaleFactor = parseFloat(saved);
                document.getElementById('positionScaleFactor').value = saved;
                document.getElementById('scaleFactorValue').textContent = saved;
                addLog(`Loaded saved position scale factor: ${saved}x`, 'info');
            }
        });

        // Initialize
        addLog('System initialized', 'success');

        // ========== JOYSTICK CONTROL ==========

        // Joystick Canvas Setup
        const joystickCanvas = document.getElementById('joystickCanvas');
        const joystickCtx = joystickCanvas.getContext('2d');
        const joystickRadius = 130; // Radius of joystick pad
        const joystickCenter = { x: 140, y: 140 }; // Center of 280x280 canvas

        // Joystick state
        let joystickActive = false;
        let currentJoystickAngle = 0;
        let currentJoystickPosition = { x: 0, y: 0 };
        let lastPositionUpdateTime = 0;
        const POSITION_UPDATE_THROTTLE = 50; // ms (20Hz update rate)

        // Draw joystick interface
        function drawJoystick() {
            // Clear canvas
            joystickCtx.clearRect(0, 0, joystickCanvas.width, joystickCanvas.height);

            // Draw outer circle (pad boundary)
            joystickCtx.beginPath();
            joystickCtx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI);
            joystickCtx.strokeStyle = '#6c757d';
            joystickCtx.lineWidth = 2;
            joystickCtx.stroke();
            joystickCtx.fillStyle = '#ffffff';
            joystickCtx.fill();

            // Draw crosshairs (cardinal directions)
            joystickCtx.strokeStyle = '#dee2e6';
            joystickCtx.lineWidth = 1;

            // Horizontal line
            joystickCtx.beginPath();
            joystickCtx.moveTo(joystickCenter.x - joystickRadius, joystickCenter.y);
            joystickCtx.lineTo(joystickCenter.x + joystickRadius, joystickCenter.y);
            joystickCtx.stroke();

            // Vertical line
            joystickCtx.beginPath();
            joystickCtx.moveTo(joystickCenter.x, joystickCenter.y - joystickRadius);
            joystickCtx.lineTo(joystickCenter.x, joystickCenter.y + joystickRadius);
            joystickCtx.stroke();

            // Draw center point
            joystickCtx.beginPath();
            joystickCtx.arc(joystickCenter.x, joystickCenter.y, 5, 0, 2 * Math.PI);
            joystickCtx.fillStyle = '#6c757d';
            joystickCtx.fill();

            // Draw angle labels
            joystickCtx.fillStyle = '#6c757d';
            joystickCtx.font = '12px Arial';
            joystickCtx.textAlign = 'center';
            joystickCtx.fillText('0Â°', joystickCenter.x + joystickRadius + 15, joystickCenter.y + 5);
            joystickCtx.fillText('90Â°', joystickCenter.x, joystickCenter.y - joystickRadius - 10);
            joystickCtx.fillText('180Â°', joystickCenter.x - joystickRadius - 20, joystickCenter.y + 5);
            joystickCtx.fillText('270Â°', joystickCenter.x, joystickCenter.y + joystickRadius + 20);

            // If joystick is active, draw cursor position
            if (joystickActive) {
                // Draw line from center to cursor
                joystickCtx.beginPath();
                joystickCtx.moveTo(joystickCenter.x, joystickCenter.y);
                joystickCtx.lineTo(currentJoystickPosition.x, currentJoystickPosition.y);
                joystickCtx.strokeStyle = '#0d6efd';
                joystickCtx.lineWidth = 2;
                joystickCtx.stroke();

                // Draw cursor point
                joystickCtx.beginPath();
                joystickCtx.arc(currentJoystickPosition.x, currentJoystickPosition.y, 8, 0, 2 * Math.PI);
                joystickCtx.fillStyle = '#0d6efd';
                joystickCtx.fill();
                joystickCtx.strokeStyle = '#ffffff';
                joystickCtx.lineWidth = 2;
                joystickCtx.stroke();
            }
        }

        // Convert canvas coordinates to angle and position
        function canvasToAnglePosition(canvasX, canvasY) {
            // Get offset from center
            const dx = canvasX - joystickCenter.x;
            const dy = -(canvasY - joystickCenter.y); // Invert Y (canvas Y increases downward)

            // Calculate angle using atan2 (returns radians: -Ï€ to Ï€)
            // atan2(y, x) gives angle where 0 = right, Ï€/2 = up
            let angleRadians = Math.atan2(dy, dx);

            // Convert to degrees
            let angleDegrees = angleRadians * (180 / Math.PI);

            // Normalize to 0-360 range
            if (angleDegrees < 0) {
                angleDegrees += 360;
            }

            // Convert angle to motor position (turns)
            // 360Â° = 1 turn
            const positionTurns = angleDegrees / 360;

            return {
                angle: angleDegrees,
                position: positionTurns,
                x: canvasX,
                y: canvasY
            };
        }

        // Clamp point to circle boundary
        function clampToCircle(x, y) {
            const dx = x - joystickCenter.x;
            const dy = y - joystickCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= joystickRadius) {
                return { x, y };
            }

            // Scale to circle edge
            const scale = joystickRadius / distance;
            return {
                x: joystickCenter.x + dx * scale,
                y: joystickCenter.y + dy * scale
            };
        }

        // Get canvas coordinates from event (handles both mouse and touch)
        function getCanvasCoordinates(event) {
            const rect = joystickCanvas.getBoundingClientRect();

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Mouse/touch down - start tracking
        function onJoystickStart(event) {
            event.preventDefault();
            joystickActive = true;

            const coords = getCanvasCoordinates(event);
            const clamped = clampToCircle(coords.x, coords.y);
            currentJoystickPosition = clamped;

            const result = canvasToAnglePosition(clamped.x, clamped.y);
            currentJoystickAngle = result.angle;

            updateJoystickDisplay(result.angle, result.position);
            sendThrottledPosition(result.position);
            drawJoystick();
        }

        // Mouse/touch move - update position
        function onJoystickMove(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const coords = getCanvasCoordinates(event);
            const clamped = clampToCircle(coords.x, coords.y);
            currentJoystickPosition = clamped;

            const result = canvasToAnglePosition(clamped.x, clamped.y);
            currentJoystickAngle = result.angle;

            updateJoystickDisplay(result.angle, result.position);
            sendThrottledPosition(result.position);
            drawJoystick();
        }

        // Mouse/touch up - stop tracking
        function onJoystickEnd(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const holdPosition = document.getElementById('joystickHoldPosition').checked;

            if (!holdPosition) {
                // Return to center (position 0)
                socket.emit('set_position', { position: 0 });
                addLog('Joystick released - returning to position 0', 'info');
                currentJoystickAngle = 0;
                updateJoystickDisplay(0, 0);
            } else {
                addLog(`Joystick released - holding position ${currentJoystickAngle.toFixed(1)}Â°`, 'info');
            }

            joystickActive = false;
            drawJoystick();
        }

        // Throttled position sending
        function sendThrottledPosition(position) {
            const now = Date.now();
            if (now - lastPositionUpdateTime >= POSITION_UPDATE_THROTTLE) {
                // Apply scaling factor
                const scaledPosition = position * positionScaleFactor;
                socket.emit('set_position', { position: scaledPosition });
                lastPositionUpdateTime = now;
            }
        }

        // Update display elements
        function updateJoystickDisplay(angle, position) {
            document.getElementById('joystickAngle').textContent = angle.toFixed(1);
            document.getElementById('joystickPosition').textContent = position.toFixed(3);
        }

        // Register event listeners for joystick
        joystickCanvas.addEventListener('mousedown', onJoystickStart);
        joystickCanvas.addEventListener('mousemove', onJoystickMove);
        joystickCanvas.addEventListener('mouseup', onJoystickEnd);
        joystickCanvas.addEventListener('mouseleave', onJoystickEnd);

        // Touch events for mobile
        joystickCanvas.addEventListener('touchstart', onJoystickStart);
        joystickCanvas.addEventListener('touchmove', onJoystickMove);
        joystickCanvas.addEventListener('touchend', onJoystickEnd);
        joystickCanvas.addEventListener('touchcancel', onJoystickEnd);

        // Initial draw
        drawJoystick();

        // ========== ROTATION KNOB CONTROL ==========

        // Rotation Knob State Variables
        let rotationKnobActive = false;           // Currently dragging
        let cumulativeRotation = 0;               // Total rotation in degrees (unlimited)
        let lastDragAngle = 0;                    // Last cursor angle during drag
        let rotationZeroPosition = 0;             // Calibration offset (in turns)
        let lastRotationUpdateTime = 0;           // For throttling
        let initializedRotationKnob = false;      // Synced with motor position
        let currentMotorPosition = 0;             // Track current motor position from feedback
        const ROTATION_UPDATE_THROTTLE = 50;      // ms (20Hz updates)

        // SVG element references
        let rotationKnobSvg = null;
        let knobPointer = null;
        let knobGripGroup = null;

        // Create SVG Rotation Knob
        function createRotationKnob() {
            const container = document.getElementById('rotationKnobContainer');
            const svgNS = "http://www.w3.org/2000/svg";

            // Create SVG element
            rotationKnobSvg = document.createElementNS(svgNS, 'svg');
            rotationKnobSvg.setAttribute('width', '200');
            rotationKnobSvg.setAttribute('height', '200');
            rotationKnobSvg.setAttribute('id', 'rotationKnobSvg');
            rotationKnobSvg.setAttribute('viewBox', '0 0 200 200');

            // Create gradient for 3D effect
            const defs = document.createElementNS(svgNS, 'defs');
            const gradient = document.createElementNS(svgNS, 'radialGradient');
            gradient.setAttribute('id', 'knobGradient');
            gradient.setAttribute('cx', '40%');
            gradient.setAttribute('cy', '40%');

            const stop1 = document.createElementNS(svgNS, 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('style', 'stop-color:#e9ecef;stop-opacity:1');

            const stop2 = document.createElementNS(svgNS, 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('style', 'stop-color:#adb5bd;stop-opacity:1');

            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            rotationKnobSvg.appendChild(defs);

            // Create knob body (circle)
            const knobBody = document.createElementNS(svgNS, 'circle');
            knobBody.setAttribute('cx', '100');
            knobBody.setAttribute('cy', '100');
            knobBody.setAttribute('r', '80');
            knobBody.setAttribute('class', 'knob-body');
            rotationKnobSvg.appendChild(knobBody);

            // Create grip lines (radial pattern)
            knobGripGroup = document.createElementNS(svgNS, 'g');
            knobGripGroup.setAttribute('id', 'knobGripGroup');

            for (let i = 0; i < 8; i++) {
                const angle = (i * 45) * (Math.PI / 180);
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', 100 + Math.cos(angle) * 50);
                line.setAttribute('y1', 100 + Math.sin(angle) * 50);
                line.setAttribute('x2', 100 + Math.cos(angle) * 70);
                line.setAttribute('y2', 100 + Math.sin(angle) * 70);
                line.setAttribute('class', 'knob-grip-line');
                knobGripGroup.appendChild(line);
            }
            rotationKnobSvg.appendChild(knobGripGroup);

            // Create reference mark at 0Â° (12 o'clock)
            const referenceMark = document.createElementNS(svgNS, 'circle');
            referenceMark.setAttribute('cx', '100');
            referenceMark.setAttribute('cy', '15');
            referenceMark.setAttribute('r', '5');
            referenceMark.setAttribute('class', 'knob-reference-mark');
            rotationKnobSvg.appendChild(referenceMark);

            // Create pointer line (rotates with knob)
            knobPointer = document.createElementNS(svgNS, 'line');
            knobPointer.setAttribute('x1', '100');
            knobPointer.setAttribute('y1', '100');
            knobPointer.setAttribute('x2', '100');
            knobPointer.setAttribute('y2', '30');
            knobPointer.setAttribute('class', 'knob-pointer');
            knobPointer.setAttribute('id', 'knobPointer');
            rotationKnobSvg.appendChild(knobPointer);

            // Add to container
            container.appendChild(rotationKnobSvg);

            // Register event listeners
            rotationKnobSvg.addEventListener('mousedown', onRotationKnobMouseDown);
            rotationKnobSvg.addEventListener('touchstart', onRotationKnobTouchStart);
        }

        // Get angle from cursor position relative to knob center
        function getAngleFromCursor(clientX, clientY) {
            const rect = rotationKnobSvg.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = clientX - centerX;
            const dy = clientY - centerY;

            // Calculate angle in degrees (0Â° = top, clockwise)
            let angle = Math.atan2(dx, -dy) * (180 / Math.PI);
            if (angle < 0) angle += 360;

            return angle;
        }

        // Calculate angle delta handling wraparound
        function calculateAngleDelta(newAngle, oldAngle) {
            let delta = newAngle - oldAngle;

            // Handle wraparound at 0Â°/360Â° boundary
            if (delta > 180) {
                delta -= 360;  // Clockwise wrap
            } else if (delta < -180) {
                delta += 360;  // Counter-clockwise wrap
            }

            return delta;
        }

        // Mouse event handlers
        function onRotationKnobMouseDown(event) {
            event.preventDefault();
            rotationKnobActive = true;
            lastDragAngle = getAngleFromCursor(event.clientX, event.clientY);

            document.addEventListener('mousemove', onRotationKnobMouseMove);
            document.addEventListener('mouseup', onRotationKnobMouseUp);
        }

        function onRotationKnobMouseMove(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            const newAngle = getAngleFromCursor(event.clientX, event.clientY);
            const delta = calculateAngleDelta(newAngle, lastDragAngle);
            cumulativeRotation += delta;
            lastDragAngle = newAngle;

            updateRotationKnobDisplay();

            // Throttle position updates to motor
            const now = Date.now();
            if (now - lastRotationUpdateTime > ROTATION_UPDATE_THROTTLE) {
                sendRotationPosition();
                lastRotationUpdateTime = now;
            }
        }

        function onRotationKnobMouseUp(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            rotationKnobActive = false;
            sendRotationPosition();  // Final position update

            document.removeEventListener('mousemove', onRotationKnobMouseMove);
            document.removeEventListener('mouseup', onRotationKnobMouseUp);
        }

        // Touch event handlers
        function onRotationKnobTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 0) return;

            rotationKnobActive = true;
            const touch = event.touches[0];
            lastDragAngle = getAngleFromCursor(touch.clientX, touch.clientY);

            document.addEventListener('touchmove', onRotationKnobTouchMove);
            document.addEventListener('touchend', onRotationKnobTouchEnd);
            document.addEventListener('touchcancel', onRotationKnobTouchEnd);
        }

        function onRotationKnobTouchMove(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();
            if (event.touches.length === 0) return;

            const touch = event.touches[0];
            const newAngle = getAngleFromCursor(touch.clientX, touch.clientY);
            const delta = calculateAngleDelta(newAngle, lastDragAngle);
            cumulativeRotation += delta;
            lastDragAngle = newAngle;

            updateRotationKnobDisplay();

            // Throttle position updates to motor
            const now = Date.now();
            if (now - lastRotationUpdateTime > ROTATION_UPDATE_THROTTLE) {
                sendRotationPosition();
                lastRotationUpdateTime = now;
            }
        }

        function onRotationKnobTouchEnd(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            rotationKnobActive = false;
            sendRotationPosition();  // Final position update

            document.removeEventListener('touchmove', onRotationKnobTouchMove);
            document.removeEventListener('touchend', onRotationKnobTouchEnd);
            document.removeEventListener('touchcancel', onRotationKnobTouchEnd);
        }

        // Update rotation knob visual display
        function updateRotationKnobDisplay() {
            // Update SVG pointer rotation
            if (knobPointer) {
                knobPointer.setAttribute('transform', `rotate(${cumulativeRotation} 100 100)`);
            }

            // Also rotate grip lines for better visual feedback
            if (knobGripGroup) {
                knobGripGroup.setAttribute('transform', `rotate(${cumulativeRotation} 100 100)`);
            }

            // Update text displays
            const normalizedDegrees = ((cumulativeRotation % 360) + 360) % 360;
            const turns = cumulativeRotation / 360;
            const rotationCount = Math.floor(Math.abs(cumulativeRotation) / 360);

            document.getElementById('rotationDegrees').textContent = normalizedDegrees.toFixed(1);
            document.getElementById('rotationTurns').textContent = turns.toFixed(3);
            document.getElementById('rotationCount').textContent = rotationCount;
        }

        // Send rotation position to motor
        function sendRotationPosition() {
            const turns = cumulativeRotation / 360;
            const absolutePosition = rotationZeroPosition + turns;
            // Apply scaling factor
            const scaledPosition = absolutePosition * positionScaleFactor;
            console.log(`Sending position: ${scaledPosition.toFixed(3)} turns (unscaled: ${absolutePosition.toFixed(3)}, scale: ${positionScaleFactor}x)`);
            socket.emit('set_position', { position: scaledPosition });
        }

        // Calibration: Set current motor position as zero reference
        function setRotationZero() {
            rotationZeroPosition = currentMotorPosition;
            cumulativeRotation = 0;
            updateRotationKnobDisplay();
            addLog('Rotation zero point calibrated', 'success');
        }

        // Reset: Return to calibrated zero position
        function resetRotationToZero() {
            cumulativeRotation = 0;
            updateRotationKnobDisplay();
            sendRotationPosition();
            addLog('Returning to zero position', 'info');
        }

        // 2D Robot Arm Visualizer
        const robotVisualizer = {
            canvas: document.getElementById('robotCanvas'),
            ctx: null,
            // Robot configuration (from robot_config_2dof_test.json)
            linkLengths: [0.3, 0.25],  // meters (a parameters from DH)
            jointAngles: [0.0, 0.0],    // radians
            scale: 400,                 // pixels per meter
            centerX: 140,
            centerY: 220,

            init() {
                this.ctx = this.canvas.getContext('2d');
                this.draw();
            },

            // Forward kinematics: compute end effector position
            computeFK(j0, j1) {
                const L1 = this.linkLengths[0];
                const L2 = this.linkLengths[1];

                // Joint 0 position (end of link 1)
                const x1 = L1 * Math.cos(j0);
                const y1 = L1 * Math.sin(j0);

                // End effector position (end of link 2)
                const x2 = x1 + L2 * Math.cos(j0 + j1);
                const y2 = y1 + L2 * Math.sin(j0 + j1);

                return { x1, y1, x2, y2 };
            },

            // Convert world coordinates to canvas coordinates
            worldToCanvas(x, y) {
                return {
                    x: this.centerX + x * this.scale,
                    y: this.centerY - y * this.scale  // Flip Y axis
                };
            },

            draw() {
                const ctx = this.ctx;
                const canvas = this.canvas;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw workspace boundary circle (approximate reach)
                const maxReach = this.linkLengths[0] + this.linkLengths[1];
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, maxReach * this.scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);

                // Compute joint and end effector positions
                const fk = this.computeFK(this.jointAngles[0], this.jointAngles[1]);
                const base = this.worldToCanvas(0, 0);
                const joint1 = this.worldToCanvas(fk.x1, fk.y1);
                const endEffector = this.worldToCanvas(fk.x2, fk.y2);

                // Draw link 1
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(base.x, base.y);
                ctx.lineTo(joint1.x, joint1.y);
                ctx.stroke();

                // Draw link 2
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(joint1.x, joint1.y);
                ctx.lineTo(endEffector.x, endEffector.y);
                ctx.stroke();

                // Draw base (fixed)
                ctx.fillStyle = '#757575';
                ctx.beginPath();
                ctx.arc(base.x, base.y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw joint 1
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.arc(joint1.x, joint1.y, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Draw end effector
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(endEffector.x, endEffector.y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw axes
                ctx.strokeStyle = '#9E9E9E';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                // X axis
                ctx.beginPath();
                ctx.moveTo(0, this.centerY);
                ctx.lineTo(canvas.width, this.centerY);
                ctx.stroke();
                // Y axis
                ctx.beginPath();
                ctx.moveTo(this.centerX, 0);
                ctx.lineTo(this.centerX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);

                // Update end effector position display
                document.getElementById('endEffectorPos').textContent =
                    `End Effector: (${fk.x2.toFixed(3)}, ${fk.y2.toFixed(3)}) m`;
            },

            updateJointAngles(angles) {
                this.jointAngles = angles;
                this.draw();
            }
        };

        // Initialize visualizer on page load
        robotVisualizer.init();

        // IK Control Functions
        // Joint slider input handlers
        document.getElementById('joint0Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint0Value').textContent = value.toFixed(3);
            // Update visualizer with slider values
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            robotVisualizer.updateJointAngles([value, j1]);
        });

        document.getElementById('joint1Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint1Value').textContent = value.toFixed(3);
            // Update visualizer with slider values
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            robotVisualizer.updateJointAngles([j0, value]);
        });

        document.getElementById('joint2Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint2Value').textContent = value.toFixed(3);
            // Update visualizer with slider values (3-DOF mode)
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            robotVisualizer.updateJointAngles([j0, j1, value]);
        });

        // Set joint angles for multi-motor control
        function setJointAngles() {
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            const j2 = parseFloat(document.getElementById('joint2Slider').value);

            const config = document.getElementById('robotConfigSelect').value;

            if (config === 'single') {
                // Single motor mode - use existing position control
                const scaledPos = j0 * positionScaleFactor;
                socket.emit('set_position', { position: scaledPos });
                addLog(`Setting position to ${j0.toFixed(3)} rad (scaled: ${scaledPos.toFixed(3)})`, 'info');
            } else if (config === '2dof') {
                // 2-DOF mode
                socket.emit('set_joint_angles', { joints: [j0, j1] });
                addLog(`Setting joint angles: J0=${j0.toFixed(3)}, J1=${j1.toFixed(3)} rad`, 'info');
            } else if (config === '3dof' || config === '6dof') {
                // 3-DOF or 6-DOF mode (currently only 3 joints)
                socket.emit('set_joint_angles', { joints: [j0, j1, j2] });
                addLog(`Setting joint angles: J0=${j0.toFixed(3)}, J1=${j1.toFixed(3)}, J2=${j2.toFixed(3)} rad`, 'info');
            }
        }

        // Robot configuration dropdown handler
        document.getElementById('robotConfigSelect').addEventListener('change', function(e) {
            const config = e.target.value;
            addLog(`Robot configuration: ${config}`, 'info');

            // Show/hide controls based on config
            const cartesianControls = document.getElementById('cartesianControls');
            const joint1Container = document.getElementById('joint1Slider').parentElement;
            const joint2Container = document.getElementById('joint2Container');

            if (config === 'single') {
                // Single motor - show only J0
                joint1Container.style.display = 'none';
                joint2Container.style.display = 'none';
                cartesianControls.style.display = 'none';
            } else if (config === '2dof') {
                // 2-DOF - show J0 and J1
                joint1Container.style.display = 'block';
                joint2Container.style.display = 'none';
                cartesianControls.style.display = 'none';
            } else if (config === '3dof' || config === '6dof') {
                // 3-DOF or 6-DOF - show all joints and enable Cartesian controls
                joint1Container.style.display = 'block';
                joint2Container.style.display = 'block';
                cartesianControls.style.display = 'block';
            }
        });

        // Cartesian control - move to X, Y, Z target using IK
        function moveToCartesianTarget() {
            const x = parseFloat(document.getElementById('xSlider').value);
            const y = parseFloat(document.getElementById('ySlider').value);
            const z = parseFloat(document.getElementById('zSlider').value);

            const config = document.getElementById('robotConfigSelect').value;

            if (config !== '3dof' && config !== '6dof') {
                addLog('Cartesian control requires 3-DOF or 6-DOF configuration', 'warning');
                return;
            }

            // Send Cartesian target to backend (IK will be computed there)
            socket.emit('set_cartesian_target', {
                x: x,
                y: y,
                z: z,
                config: config
            });

            addLog(`Moving to Cartesian target: X=${x.toFixed(3)}, Y=${y.toFixed(3)}, Z=${z.toFixed(3)} m`, 'info');
            document.getElementById('ikStatus').textContent = 'Computing IK...';
            document.getElementById('ikStatus').className = 'badge bg-warning';
        }

        // Cartesian slider input handlers
        document.getElementById('xSlider').addEventListener('input', function(e) {
            document.getElementById('targetX').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('ySlider').addEventListener('input', function(e) {
            document.getElementById('targetY').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('zSlider').addEventListener('input', function(e) {
            document.getElementById('targetZ').textContent = parseFloat(e.target.value).toFixed(3);
        });

        // Mode switching function
        function switchControlMode(mode) {
            document.getElementById('velocityControls').style.display =
                mode === 'velocity' ? 'block' : 'none';
            document.getElementById('joystickControls').style.display =
                mode === 'joystick' ? 'block' : 'none';
            document.getElementById('rotationControls').style.display =
                mode === 'rotation' ? 'block' : 'none';
            document.getElementById('ikControls').style.display =
                mode === 'ik' ? 'block' : 'none';
        }

        // Register mode switcher listeners
        document.querySelectorAll('input[name="controlMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const mode = e.target.id.replace('Mode', '');
                switchControlMode(mode);
                addLog(`Switched to ${mode} control mode`, 'info');
            });
        });

        // ========== PRESET UI FUNCTIONS ==========
        function saveCurrentAsPreset() {
            const currentPos = parseFloat(document.getElementById('currentPosition').textContent);
            if (isNaN(currentPos)) {
                addLog('No position available to save', 'warning');
                return;
            }

            const name = prompt('Enter preset name:', `Position ${currentPos.toFixed(3)}`);
            if (!name) return;

            try {
                const preset = presetManager.addPreset(name, currentPos);
                renderPresetList();
                addLog(`Preset "${name}" saved at ${currentPos.toFixed(3)} turns (hotkey: ${preset.hotkey})`, 'success');
            } catch (e) {
                addLog(`Error saving preset: ${e.message}`, 'danger');
            }
        }

        function goToPreset(id) {
            const position = presetManager.goToPreset(id);
            if (position !== null) {
                const scaledPosition = position * positionScaleFactor;
                socket.emit('set_position', { position: scaledPosition });
                const preset = presetManager.data.presets.find(p => p.id === id);
                addLog(`Going to preset "${preset.name}": ${position.toFixed(3)} turns`, 'info');
            }
        }

        function openPresetManager() {
            renderPresetManagerList();
            const modal = new bootstrap.Modal(document.getElementById('presetManagerModal'));
            modal.show();
        }

        function renderPresetList() {
            const container = document.getElementById('presetsList');
            if (presetManager.data.presets.length === 0) {
                container.innerHTML = '<small class="text-muted">No presets saved</small>';
                return;
            }

            let html = '';
            presetManager.data.presets.forEach(preset => {
                html += `
                    <button class="btn btn-sm preset-btn"
                            style="background-color: ${preset.color}; color: white; border-color: ${preset.color};"
                            onclick="goToPreset('${preset.id}')"
                            title="Hotkey: ${preset.hotkey}">
                        ${preset.name} <span class="badge bg-light text-dark">${preset.hotkey}</span>
                    </button>
                `;
            });
            container.innerHTML = html;
        }

        function renderPresetManagerList() {
            const container = document.getElementById('presetManagerList');
            if (presetManager.data.presets.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">No presets saved</p>';
                return;
            }

            let html = '<div class="list-group">';
            presetManager.data.presets.forEach(preset => {
                html += `
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${preset.name}</strong><br>
                                <small class="text-muted">Position: ${preset.position.toFixed(3)} turns | Hotkey: ${preset.hotkey}</small>
                            </div>
                            <button class="btn btn-sm btn-outline-danger" onclick="deletePreset('${preset.id}')">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function deletePreset(id) {
            if (confirm('Delete this preset?')) {
                presetManager.removePreset(id);
                renderPresetList();
                renderPresetManagerList();
                addLog('Preset deleted', 'info');
            }
        }

        // ========== WAYPOINT UI FUNCTIONS ==========
        function executeWaypoint() {
            const select = document.getElementById('waypointSelect');
            const waypointId = select.value;
            if (!waypointId) {
                addLog('Please select a waypoint to execute', 'warning');
                return;
            }

            waypointExecutor.executeWaypoint(waypointId).catch(e => {
                addLog(`Waypoint execution error: ${e.message}`, 'danger');
                waypointExecutor.stop();
            });
        }

        function stopWaypoint() {
            waypointExecutor.stop();
            addLog('Waypoint execution stopped', 'warning');
        }

        function openWaypointBuilder() {
            // Clear previous inputs
            document.getElementById('waypointName').value = '';
            document.getElementById('waypointPositionsList').innerHTML = '';
            document.getElementById('waypointPauseDuration').value = 1000;
            document.getElementById('waypointLoop').checked = false;

            // Add first position input
            addWaypointPosition();

            const modal = new bootstrap.Modal(document.getElementById('waypointBuilderModal'));
            modal.show();
        }

        function addWaypointPosition() {
            const container = document.getElementById('waypointPositionsList');
            const index = container.children.length;

            const div = document.createElement('div');
            div.className = 'input-group mb-2';
            div.innerHTML = `
                <span class="input-group-text">${index + 1}</span>
                <input type="number" class="form-control waypoint-position-input"
                       placeholder="Position (turns)" step="0.1" value="0">
                <button class="btn btn-outline-danger" onclick="removeWaypointPosition(this)" type="button">Ã—</button>
            `;
            container.appendChild(div);
        }

        function removeWaypointPosition(button) {
            button.parentElement.remove();
            // Renumber remaining positions
            const container = document.getElementById('waypointPositionsList');
            Array.from(container.children).forEach((child, index) => {
                child.querySelector('.input-group-text').textContent = index + 1;
            });
        }

        function saveWaypoint() {
            const name = document.getElementById('waypointName').value.trim();
            if (!name) {
                addLog('Please enter a waypoint name', 'warning');
                return;
            }

            const positionInputs = document.querySelectorAll('.waypoint-position-input');
            const positions = Array.from(positionInputs).map(input => parseFloat(input.value));

            if (positions.length === 0) {
                addLog('Please add at least one position', 'warning');
                return;
            }

            if (positions.some(isNaN)) {
                addLog('All positions must be valid numbers', 'warning');
                return;
            }

            const pauseDuration = parseInt(document.getElementById('waypointPauseDuration').value);
            const loop = document.getElementById('waypointLoop').checked;

            try {
                presetManager.addWaypoint(name, positions, pauseDuration, loop);
                populateWaypointSelect();
                addLog(`Waypoint "${name}" created with ${positions.length} positions`, 'success');

                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('waypointBuilderModal'));
                modal.hide();
            } catch (e) {
                addLog(`Error creating waypoint: ${e.message}`, 'danger');
            }
        }

        function populateWaypointSelect() {
            const select = document.getElementById('waypointSelect');
            const currentValue = select.value;

            let html = '<option value="">-- Select Waypoint --</option>';
            presetManager.data.waypoints.forEach(waypoint => {
                html += `<option value="${waypoint.id}">${waypoint.name} (${waypoint.positions.length} steps)</option>`;
            });

            select.innerHTML = html;
            select.value = currentValue; // Restore selection if possible
        }

        // ========== KEYBOARD SHORTCUT UI FUNCTIONS ==========
        function updateShortcutsToggleUI() {
            const toggleText = document.getElementById('toggleShortcutsText');
            if (toggleText) {
                toggleText.textContent = keyboardShortcutManager.enabled ? 'Disable Shortcuts' : 'Enable Shortcuts';
            }
        }

        // ========== CALIBRATION UI FUNCTIONS ==========
        function startCalibration() {
            if (calibrationExecutor.isCalibrating) {
                addLog('Calibration already in progress', 'warning');
                return;
            }

            const confirmed = confirm(
                'This will automatically move the motor to zero, rotate 1 turn, and return to zero to calibrate the position scale factor.\n\n' +
                'Ensure the motor can safely rotate and nothing will be damaged.\n\n' +
                'Continue with calibration?'
            );

            if (!confirmed) return;

            addLog('Starting auto-calibration...', 'info');
            calibrationExecutor.startCalibration().catch(error => {
                addLog(`Calibration failed: ${error.message}`, 'danger');
            });
        }

        function applyCalibrationResults() {
            const recommendedScaleFactor = calibrationExecutor.getRecommendedScaleFactor();

            if (recommendedScaleFactor > 0) {
                // Update the scale factor
                const scaleFactorSlider = document.getElementById('positionScaleFactor');
                if (scaleFactorSlider) {
                    scaleFactorSlider.value = recommendedScaleFactor;
                    updateScaleFactorDisplay(recommendedScaleFactor);
                }

                addLog(`Scale factor updated to ${recommendedScaleFactor.toFixed(2)}x`, 'success');

                // Close the modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('calibrationResultsModal'));
                if (modal) modal.hide();
            } else {
                addLog('No recommended scale factor available', 'warning');
            }
        }

        // ========== SESSION RECORDING/PLAYBACK UI FUNCTIONS ==========
        let recordingDurationTimer = null;
        let sequenceStorage = []; // In-memory storage for sequences

        function startRecording() {
            const sessionName = prompt('Enter session name (optional):', `Recording_${new Date().toLocaleTimeString()}`);

            try {
                sessionRecorder.startRecording(sessionName || undefined);

                // Update UI
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('recordingIndicator').style.display = 'block';

                // Start duration display timer
                recordingDurationTimer = setInterval(() => {
                    const duration = sessionRecorder.getDuration();
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    document.getElementById('recordingDuration').textContent =
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 100);

            } catch (error) {
                addLog(`Recording error: ${error.message}`, 'danger');
            }
        }

        function stopRecording() {
            try {
                const sessionData = sessionRecorder.stopRecording();

                if (sessionData) {
                    // Save to memory
                    sequenceStorage.push(sessionData);
                    populateSequenceSelect();

                    // Send to backend for persistent storage (if available)
                    socket.emit('save_session', sessionData);
                }

                // Update UI
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('recordingIndicator').style.display = 'none';

                // Stop duration timer
                clearInterval(recordingDurationTimer);

            } catch (error) {
                addLog(`Stop recording error: ${error.message}`, 'danger');
            }
        }

        function populateSequenceSelect() {
            const select = document.getElementById('sequenceSelect');
            const currentValue = select.value;

            let html = '<option value="">-- Select Sequence --</option>';
            sequenceStorage.forEach((session, index) => {
                const duration = session.session_metadata.duration_seconds.toFixed(1);
                const points = session.session_metadata.data_points_count;
                html += `<option value="${index}">${session.session_metadata.name} (${duration}s, ${points} pts)</option>`;
            });

            select.innerHTML = html;
            select.value = currentValue;
        }

        function playSequence() {
            const select = document.getElementById('sequenceSelect');
            const selectedIndex = select.value;

            if (!selectedIndex || selectedIndex === '') {
                addLog('Please select a sequence to play', 'warning');
                return;
            }

            const sessionData = sequenceStorage[parseInt(selectedIndex)];

            try {
                sessionPlayback.loadSession(sessionData);
                sessionPlayback.play();

                // Update UI
                document.getElementById('playSequenceBtn').disabled = true;
                document.getElementById('pauseSequenceBtn').disabled = false;
                document.getElementById('stopSequenceBtn').disabled = false;
                document.getElementById('playbackProgress').style.display = 'block';

                const duration = sessionData.session_metadata.duration_seconds;
                document.getElementById('playbackDuration').textContent = formatTime(duration);

            } catch (error) {
                addLog(`Playback error: ${error.message}`, 'danger');
            }
        }

        function pauseSequence() {
            sessionPlayback.pause();

            // Update UI
            document.getElementById('playSequenceBtn').disabled = false;
            document.getElementById('pauseSequenceBtn').disabled = true;
        }

        function stopSequence() {
            sessionPlayback.stop();

            // Update UI
            document.getElementById('playSequenceBtn').disabled = false;
            document.getElementById('pauseSequenceBtn').disabled = true;
            document.getElementById('stopSequenceBtn').disabled = true;
            document.getElementById('playbackProgress').style.display = 'none';

            // Reset progress bar
            document.getElementById('playbackProgressBar').style.width = '0%';
            document.getElementById('playbackTime').textContent = '0:00';
        }

        function updatePlaybackSpeed(value) {
            const speed = parseFloat(value);
            document.getElementById('playbackSpeedValue').textContent = speed.toFixed(1);
            document.getElementById('playbackSpeed').textContent = speed.toFixed(1) + 'x';

            sessionPlayback.setSpeed(speed);
        }

        function updatePlaybackProgress(progress, currentTime) {
            document.getElementById('playbackProgressBar').style.width = progress + '%';
            document.getElementById('playbackTime').textContent = formatTime(currentTime);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function openSequenceLibrary() {
            renderSequenceLibrary();
            const modal = new bootstrap.Modal(document.getElementById('sequenceLibraryModal'));
            modal.show();
        }

        function renderSequenceLibrary() {
            const container = document.getElementById('sequenceLibraryList');

            if (sequenceStorage.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">No sequences recorded</p>';
                return;
            }

            let html = '<div class="list-group">';
            sequenceStorage.forEach((session, index) => {
                const metadata = session.session_metadata;
                const duration = metadata.duration_seconds.toFixed(1);
                const points = metadata.data_points_count;
                const date = new Date(metadata.start_time).toLocaleString();

                html += `
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${metadata.name}</strong><br>
                                <small class="text-muted">
                                    Duration: ${duration}s | Points: ${points} | ${date}
                                </small>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-sm btn-outline-primary" onclick="loadAndPlaySequence(${index})">
                                    <i class="bi bi-play"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-success" onclick="downloadSequence(${index})">
                                    <i class="bi bi-download"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteSequenceByIndex(${index})">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function loadAndPlaySequence(index) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('sequenceLibraryModal'));
            if (modal) modal.hide();

            // Set selection and play
            document.getElementById('sequenceSelect').value = index;
            playSequence();
        }

        function downloadSequence(index) {
            const sessionData = sequenceStorage[index];
            const dataStr = JSON.stringify(sessionData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${sessionData.session_metadata.name}.json`;
            a.click();

            URL.revokeObjectURL(url);
            addLog(`Downloaded: ${sessionData.session_metadata.name}.json`, 'success');
        }

        function deleteSequenceByIndex(index) {
            const sessionData = sequenceStorage[index];

            if (confirm(`Delete sequence "${sessionData.session_metadata.name}"?`)) {
                sequenceStorage.splice(index, 1);
                populateSequenceSelect();
                renderSequenceLibrary();
                addLog('Sequence deleted', 'info');
            }
        }

        function deleteSequence() {
            const select = document.getElementById('sequenceSelect');
            const selectedIndex = select.value;

            if (!selectedIndex || selectedIndex === '') {
                addLog('Please select a sequence to delete', 'warning');
                return;
            }

            deleteSequenceByIndex(parseInt(selectedIndex));
        }

        // ========== VELOCITY RAMPING UI FUNCTIONS ==========
        function updateAccelerationDisplay(value) {
            const accel = parseFloat(value);
            document.getElementById('accelerationValue').textContent = accel.toFixed(1);

            // Send to backend
            socket.emit('set_velocity_ramp', {
                acceleration: accel,
                deceleration: parseFloat(document.getElementById('decelerationLimit').value)
            });

            localStorage.setItem('accelerationLimit', value);
            addLog(`Acceleration limit set to ${accel.toFixed(1)} turns/secÂ²`, 'info');
        }

        function updateDecelerationDisplay(value) {
            const decel = parseFloat(value);
            document.getElementById('decelerationValue').textContent = decel.toFixed(1);

            // Send to backend
            socket.emit('set_velocity_ramp', {
                acceleration: parseFloat(document.getElementById('accelerationLimit').value),
                deceleration: decel
            });

            localStorage.setItem('decelerationLimit', value);
            addLog(`Deceleration limit set to ${decel.toFixed(1)} turns/secÂ²`, 'info');
        }

        function toggleVelocityRamping(enabled) {
            const controlsDiv = document.getElementById('velocityRampingControls');
            controlsDiv.style.opacity = enabled ? '1' : '0.5';

            // Send to backend
            socket.emit('set_velocity_ramp_enabled', { enabled: enabled });

            localStorage.setItem('velocityRampingEnabled', enabled);
            addLog(`Velocity ramping ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        // Load velocity ramping settings from localStorage on page load
        window.addEventListener('DOMContentLoaded', function() {
            const savedAccel = localStorage.getItem('accelerationLimit');
            const savedDecel = localStorage.getItem('decelerationLimit');
            const savedEnabled = localStorage.getItem('velocityRampingEnabled');

            if (savedAccel) {
                document.getElementById('accelerationLimit').value = savedAccel;
                updateAccelerationDisplay(savedAccel);
            }

            if (savedDecel) {
                document.getElementById('decelerationLimit').value = savedDecel;
                updateDecelerationDisplay(savedDecel);
            }

            if (savedEnabled !== null) {
                const enabled = savedEnabled === 'true';
                document.getElementById('velocityRampingEnabled').checked = enabled;
                toggleVelocityRamping(enabled);
            }
        });

        // Initialize presets and waypoints on page load
        window.addEventListener('DOMContentLoaded', function() {
            renderPresetList();
            populateWaypointSelect();
            addLog('Presets and waypoints loaded', 'info');
        });

        // Initialize rotation knob on page load
        createRotationKnob();

    </script>
</body>
</html>
