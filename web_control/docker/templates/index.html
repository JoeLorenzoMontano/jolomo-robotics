<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODrive Motor Control Pro</title>
    
    <!-- External Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <style>
        :root {
            /* Modern Dark Theme Colors */
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f29;
            --bg-tertiary: #242b38;
            --bg-elevated: #2d3748;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #bc8cff;
            --border-color: rgba(255,255,255,0.1);
            --border-color-strong: rgba(255,255,255,0.15);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
            
            /* Spacing */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            
            /* Borders */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Top Navigation Bar */
        .top-nav {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: var(--space-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .top-nav-brand {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .top-nav-brand i {
            font-size: 1.75rem;
            color: var(--accent-blue);
        }
        
        .top-nav-status {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: var(--bg-tertiary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        .status-dot.disconnected {
            background: var(--accent-red);
            box-shadow: 0 0 10px var(--accent-red);
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .top-nav-actions {
            display: flex;
            gap: var(--space-2);
        }

        .control-mode-toggle {
            display: flex;
            gap: var(--space-1);
            background: var(--bg-tertiary);
            border-radius: var(--radius-lg);
            padding: 4px;
            border: 1px solid var(--border-color);
        }

        .mode-btn {
            padding: var(--space-2) var(--space-4);
            background: transparent;
            border: none;
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .mode-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .mode-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(88, 166, 255, 0.3);
        }

        .mode-btn i {
            font-size: 1rem;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            min-height: calc(100vh - 73px);
        }
        
        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: var(--space-4);
            overflow-y: auto;
            position: sticky;
            top: 73px;
            height: calc(100vh - 73px);
        }
        
        .sidebar-section {
            margin-bottom: var(--space-6);
        }
        
        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: var(--space-3);
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-base);
            margin-bottom: var(--space-1);
            border: 1px solid transparent;
        }
        
        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .nav-item.active {
            background: var(--bg-elevated);
            color: var(--accent-blue);
            border-color: var(--accent-blue);
            font-weight: 500;
        }
        
        .nav-item i {
            font-size: 1.25rem;
            width: 24px;
            text-align: center;
        }
        
        /* Emergency Stop */
        .emergency-stop-sidebar {
            background: linear-gradient(135deg, var(--accent-red), #dc2626);
            color: white;
            padding: var(--space-4);
            border-radius: var(--radius-md);
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1rem;
            border: none;
            width: 100%;
            box-shadow: var(--shadow);
            transition: all var(--transition-base);
        }
        
        .emergency-stop-sidebar:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .emergency-stop-sidebar:active {
            transform: translateY(0);
        }
        
        /* Main Content Area */
        .main-content {
            flex: 1;
            padding: var(--space-6);
            overflow-y: auto;
        }
        
        /* Cards */
        .card-modern {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            margin-bottom: var(--space-6);
            box-shadow: var(--shadow);
            transition: all var(--transition-base);
        }
        
        .card-modern:hover {
            border-color: var(--border-color-strong);
            box-shadow: var(--shadow-lg);
        }
        
        .card-header-modern {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-header-modern i {
            font-size: 1.5rem;
            color: var(--accent-blue);
        }
        
        .card-header-modern h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-4);
            border-bottom: 2px solid var(--border-color);
        }
        
        .tab-button {
            padding: var(--space-3) var(--space-6);
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-base);
            font-weight: 500;
            margin-bottom: -2px;
        }
        
        .tab-button:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        
        .tab-button.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn var(--transition-base);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Dual Motor Layout */
        .dual-motor-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-4);
            margin-bottom: var(--space-4);
        }

        @media (max-width: 1200px) {
            .dual-motor-container {
                grid-template-columns: 1fr;
            }
        }

        .motor-panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
        }

        .motor-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
            padding-bottom: var(--space-3);
            border-bottom: 1px solid var(--border-color);
        }

        .motor-panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .motor-panel-title i {
            font-size: 1.3rem;
        }

        .motor-panel-0 .motor-panel-title i {
            color: var(--accent-blue);
        }

        .motor-panel-1 .motor-panel-title i {
            color: rgb(188, 140, 255); /* Purple */
        }

        .motor-state-display {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-3);
        }

        .motor-state-text {
            font-weight: 600;
            color: var(--text-primary);
        }

        .motor-controls-row {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-3);
        }

        .motor-value-display {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            text-align: center;
            margin-bottom: var(--space-3);
        }

        .motor-value-display .value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent-blue);
            font-family: 'Courier New', monospace;
        }

        .motor-panel-1 .motor-value-display .value {
            color: rgb(188, 140, 255); /* Purple */
        }

        .motor-value-display .label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: var(--space-1);
        }

        .motor-health-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        .motor-health-item {
            background: var(--bg-secondary);
            padding: var(--space-2);
            border-radius: var(--radius-sm);
        }

        .motor-health-item .health-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: var(--space-1);
        }

        .motor-health-item .health-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .shared-bus-display {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin-bottom: var(--space-4);
        }

        .shared-bus-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-3);
        }

        .shared-bus-item {
            text-align: center;
            padding: var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
        }

        .shared-bus-item .bus-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-green);
            font-family: 'Courier New', monospace;
        }

        .shared-bus-item .bus-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: var(--space-1);
        }

        /* Form Controls */
        .form-group-modern {
            margin-bottom: var(--space-4);
        }
        
        .form-label-modern {
            display: block;
            font-weight: 500;
            margin-bottom: var(--space-2);
            color: var(--text-primary);
        }
        
        .form-input-modern {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: 1rem;
            transition: all var(--transition-base);
        }
        
        .form-input-modern:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        
        .form-range-modern {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-lg);
            outline: none;
            -webkit-appearance: none;
        }
        
        .form-range-modern::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all var(--transition-base);
        }
        
        .form-range-modern::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.2);
        }
        
        .form-range-modern::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        /* Buttons */
        .btn-modern {
            padding: var(--space-3) var(--space-6);
            border-radius: var(--radius-md);
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all var(--transition-base);
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            justify-content: center;
        }
        
        .btn-modern:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }
        
        .btn-modern:active {
            transform: translateY(0);
        }
        
        .btn-primary-modern {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary-modern:hover {
            background: #4a91e6;
        }
        
        .btn-success-modern {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-danger-modern {
            background: var(--accent-red);
            color: white;
        }
        
        .btn-secondary-modern {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-warning-modern {
            background: #fd7e14;
            color: white;
            border: 1px solid #dc6e00;
        }

        .btn-warning-modern:hover {
            background: #dc6e00;
        }

        .btn-group-modern {
            display: flex;
            gap: var(--space-2);
            flex-wrap: wrap;
        }
        
        /* Value Display */
        .value-display-modern {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            text-align: center;
        }
        
        .value-display-modern .value {
            font-size: 3rem;
            font-weight: 700;
            color: var(--accent-blue);
            line-height: 1;
        }
        
        .value-display-modern .label {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-top: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Chart Container */
        .chart-container-modern {
            position: relative;
            height: 250px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: var(--space-4);
        }
        
        /* Log Messages */
        .log-container {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }
        
        .log-entry {
            padding: var(--space-2);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: var(--space-2);
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-timestamp {
            color: var(--text-muted);
            min-width: 80px;
        }
        
        .log-message {
            color: var(--text-secondary);
        }
        
        .log-message.error {
            color: var(--accent-red);
        }
        
        .log-message.success {
            color: var(--accent-green);
        }
        
        .log-message.warning {
            color: var(--accent-yellow);
        }
        
        /* Status Grid */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-4);
        }
        
        .status-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-4);
        }
        
        .status-item-label {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }
        
        .status-item-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Power/Battery Monitoring Metric Cards */
        .metric-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: var(--space-3);
            text-align: center;
            transition: all 0.2s ease;
        }

        .metric-card:hover {
            background: var(--bg-tertiary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .metric-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
            font-weight: 500;
        }

        .metric-value {
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-2);
            font-family: 'Courier New', monospace;
        }

        .metric-status {
            font-size: 0.8rem;
        }

        /* Status Badge Colors for Power Monitoring */
        .voltage-normal { background-color: #28a745 !important; }
        .voltage-low { background-color: #ffc107 !important; color: #000 !important; }
        .voltage-critical { background-color: #dc3545 !important; }
        .voltage-high { background-color: #fd7e14 !important; }

        .current-normal { background-color: #28a745 !important; }
        .current-high { background-color: #ffc107 !important; color: #000 !important; }
        .current-critical { background-color: #dc3545 !important; }

        .temp-cool { background-color: #17a2b8 !important; }
        .temp-normal { background-color: #28a745 !important; }
        .temp-warm { background-color: #ffc107 !important; color: #000 !important; }
        .temp-hot { background-color: #fd7e14 !important; }
        .temp-critical { background-color: #dc3545 !important; }

        /* Canvas Controls */
        #joystickCanvas, #rotationKnobSvg {
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            background: var(--bg-tertiary);
            cursor: crosshair;
            touch-action: none;
        }

        /* Rotation Knob SVG Components */
        .knob-body {
            fill: url(#knobGradient);
            stroke: #495057;
            stroke-width: 2;
            cursor: grab;
        }

        .knob-body:active {
            cursor: grabbing;
        }

        .knob-grip-line {
            stroke: #343a40;
            stroke-width: 3;
            stroke-linecap: round;
            pointer-events: none;
        }

        .knob-pointer {
            stroke: #0d6efd;
            stroke-width: 4;
            stroke-linecap: round;
            pointer-events: none;
            filter: drop-shadow(0 0 2px rgba(13, 110, 253, 0.5));
        }

        .knob-reference-mark {
            fill: #0d6efd;
            stroke: white;
            stroke-width: 1;
            pointer-events: none;
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: var(--radius-md);
            border: 2px solid var(--bg-primary);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-strong);
        }
        
        /* Responsive */
        @media (max-width: 968px) {
            .sidebar {
                width: 200px;
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -280px;
                transition: left var(--transition-slow);
                z-index: 999;
            }
            
            .sidebar.open {
                left: 0;
            }
            
            .main-content {
                padding: var(--space-4);
            }
        }
        
        /* Bootstrap Overrides for Dark Theme */
        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }
        
        .modal-header {
            border-bottom-color: var(--border-color);
        }
        
        .modal-footer {
            border-top-color: var(--border-color);
        }
        
        .btn-close {
            filter: invert(1);
        }
        
        .form-control, .form-select {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }
        
        .form-control:focus, .form-select:focus {
            background: var(--bg-tertiary);
            border-color: var(--accent-blue);
            color: var(--text-primary);
            box-shadow: 0 0 0 0.25rem rgba(88, 166, 255, 0.25);
        }
        
        .alert {
            border-color: var(--border-color);
        }
        
        .table {
            color: var(--text-primary);
        }
        
        .table-sm td, .table-sm th {
            border-color: var(--border-color);
        }

        /* Persistent Bottom Log Panel */
        .persistent-log-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1040;
            background: var(--card-bg);
            border-top: 2px solid var(--border-color);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, height 0.3s ease;
            max-height: 60vh;
            display: flex;
            flex-direction: column;
        }

        .persistent-log-panel.collapsed {
            transform: translateY(calc(100% - 48px));
        }

        .persistent-log-panel.expanded {
            transform: translateY(0);
            height: 300px;
        }

        .log-panel-header {
            height: 48px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--space-4);
            background: var(--sidebar-bg);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }

        .log-panel-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .log-panel-title {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 600;
            color: var(--text-primary);
        }

        .log-panel-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: var(--space-2);
            transition: transform 0.3s ease;
        }

        .persistent-log-panel.expanded .log-panel-toggle i {
            transform: rotate(180deg);
        }

        .log-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-3);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.2);
        }

        .log-panel-content::-webkit-scrollbar {
            width: 8px;
        }

        .log-panel-content::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        .log-panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .log-panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .persistent-log-entry {
            margin-bottom: var(--space-1);
            padding: var(--space-1) var(--space-2);
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .persistent-log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .persistent-log-entry.success {
            color: #4ade80;
        }

        .persistent-log-entry.danger {
            color: #f87171;
        }

        .persistent-log-entry.warning {
            color: #fbbf24;
        }

        .persistent-log-entry.info {
            color: var(--text-secondary);
        }

        /* Add bottom padding to main content to prevent overlap */
        main {
            padding-bottom: 60px;
        }

        /* Battery protection badge colors */
        .badge.voltage-urgent {
            background-color: #fd7e14 !important;  /* Orange */
            color: white;
        }

        .badge.voltage-warning {
            background-color: #ffc107 !important;  /* Yellow */
            color: #212529;  /* Dark text for readability */
        }

        .badge.voltage-critical {
            background-color: #dc3545 !important;  /* Red */
            color: white;
        }

        .badge.voltage-normal {
            background-color: #28a745 !important;  /* Green */
            color: white;
        }

        .badge.voltage-high {
            background-color: #fd7e14 !important;  /* Orange */
            color: white;
        }
    </style>
</head>
<body>
    <!-- Top Navigation -->
    <nav class="top-nav">
        <div class="top-nav-brand">
            <i class="bi bi-gear-wide-connected"></i>
            <span>ODrive Control Pro</span>
        </div>
        
        <div class="top-nav-status">
            <span class="status-dot" id="statusDot"></span>
            <span id="connectionText">Connecting...</span>
        </div>

        <div class="control-mode-toggle">
            <button class="mode-btn active" id="btnIndependentMode" onclick="setMultiMotorControlMode('independent')" title="Control motors independently">
                <i class="bi bi-ui-radios"></i> Independent
            </button>
            <button class="mode-btn" id="btnCoordinatedMode" onclick="setMultiMotorControlMode('coordinated')" title="Coordinated multi-motor control">
                <i class="bi bi-link-45deg"></i> Coordinated
            </button>
        </div>

        <div class="top-nav-actions">
            <button class="btn btn-secondary-modern" onclick="requestConfig()" title="Get Configuration">
                <i class="bi bi-info-circle"></i>
            </button>
        </div>
    </nav>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <button class="emergency-stop-sidebar" onclick="emergencyStop()">
                    <i class="bi bi-octagon-fill"></i> EMERGENCY STOP
                </button>
                <button class="btn-secondary-modern" id="silenceAlertsButton" onclick="toggleAlertSilence()" style="width: 100%; margin-top: var(--space-2); font-size: 0.85rem;">
                    <i class="bi bi-bell"></i> Silence Alerts
                </button>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Control Modes</div>
                <div class="nav-item active" onclick="switchMode('manual')" id="nav-manual">
                    <i class="bi bi-sliders"></i>
                    <span>Manual Control</span>
                </div>
                <div class="nav-item" onclick="switchMode('joystick')" id="nav-joystick">
                    <i class="bi bi-controller"></i>
                    <span>Joystick</span>
                </div>
                <div class="nav-item" onclick="switchMode('rotation')" id="nav-rotation">
                    <i class="bi bi-disc"></i>
                    <span>Rotation Knob</span>
                </div>
                <div class="nav-item" onclick="switchMode('ik')" id="nav-ik">
                    <i class="bi bi-robot"></i>
                    <span>IK Control</span>
                </div>
                <div class="nav-item" onclick="switchMode('monitor')" id="nav-monitor">
                    <i class="bi bi-graph-up"></i>
                    <span>Monitoring</span>
                </div>
                <div class="nav-item" onclick="switchMode('advanced')" id="nav-advanced">
                    <i class="bi bi-gear"></i>
                    <span>Advanced</span>
                </div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Quick Info</div>

                <!-- Connection Status -->
                <div style="padding: var(--space-3); margin-bottom: var(--space-2); background: var(--bg-tertiary); border-radius: var(--radius-md); border-left: 3px solid var(--accent-green);" id="sidebarConnectionCard">
                    <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1);">
                        <i class="bi bi-wifi" style="color: var(--accent-green); font-size: 1.1rem;" id="sidebarConnectionIcon"></i>
                        <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600;">Status</span>
                    </div>
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--text-primary);" id="sidebarConnection">Connected</div>
                </div>

                <!-- Control Mode -->
                <div style="padding: var(--space-3); margin-bottom: var(--space-2); background: var(--bg-tertiary); border-radius: var(--radius-md);">
                    <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1);">
                        <i class="bi bi-gear-fill" style="color: var(--accent-blue); font-size: 1.1rem;"></i>
                        <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600;">Mode</span>
                    </div>
                    <div style="font-size: 0.85rem; font-weight: 600; color: var(--text-primary); font-family: 'Courier New', monospace;" id="sidebarControlMode">--</div>
                </div>

                <!-- Battery Voltage -->
                <div style="padding: var(--space-3); margin-bottom: var(--space-2); background: var(--bg-tertiary); border-radius: var(--radius-md);">
                    <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1);">
                        <i class="bi bi-battery-charging" style="color: var(--accent-green); font-size: 1.1rem;" id="sidebarBatteryIcon"></i>
                        <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600;">Battery</span>
                    </div>
                    <div style="display: flex; align-items: baseline; gap: var(--space-2);">
                        <span style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary); font-family: 'Courier New', monospace;" id="sidebarVoltage">--</span>
                        <span style="font-size: 0.75rem; color: var(--text-muted);">V</span>
                        <span class="badge bg-secondary" style="font-size: 0.65rem; margin-left: auto;" id="sidebarVoltageStatus">No Data</span>
                    </div>
                </div>

                <!-- FET Temperature -->
                <div style="padding: var(--space-3); margin-bottom: var(--space-3); background: var(--bg-tertiary); border-radius: var(--radius-md);">
                    <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1);">
                        <i class="bi bi-thermometer-half" style="color: var(--accent-cyan); font-size: 1.1rem;" id="sidebarTempIcon"></i>
                        <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600;">Temp</span>
                    </div>
                    <div style="display: flex; align-items: baseline; gap: var(--space-2);">
                        <span style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary); font-family: 'Courier New', monospace;" id="sidebarFetTemp">--</span>
                        <span style="font-size: 0.75rem; color: var(--text-muted);">Â°C</span>
                        <span class="badge bg-secondary" style="font-size: 0.65rem; margin-left: auto;" id="sidebarTempStatus">No Data</span>
                    </div>
                </div>

                <!-- Position Display -->
                <div class="value-display-modern" style="padding: var(--space-4); margin-bottom: var(--space-2);">
                    <div class="value" style="font-size: 1.5rem;" id="sidebarPosition">0.000</div>
                    <div class="label">Position (turns)</div>
                </div>

                <!-- Velocity Display -->
                <div class="value-display-modern" style="padding: var(--space-4);">
                    <div class="value" style="font-size: 1.5rem;" id="sidebarVelocity">0.000</div>
                    <div class="label">Velocity (t/s)</div>
                </div>
            </div>
        </aside>
        
        <!-- Main Content -->
        <main class="main-content">
            <!-- Manual Control Mode -->
            <div id="mode-manual" class="mode-section">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-sliders"></i>
                        <h2>Multi-Motor Control</h2>
                    </div>

                    <!-- Dual Motor Panels (Independent Mode) -->
                    <div class="dual-motor-container">
                        <!-- Motor 0 Panel -->
                        <div class="motor-panel motor-panel-0">
                            <div class="motor-panel-header">
                                <div class="motor-panel-title">
                                    <i class="bi bi-gear-fill"></i>
                                    Motor 0
                                </div>
                            </div>

                            <!-- Motor State -->
                            <div class="motor-state-display">
                                <span id="motor0-state-icon" style="font-size: 1.2rem;">ðŸ”´</span>
                                <span class="motor-state-text" id="motor0-state">IDLE</span>
                            </div>

                            <!-- Enable/Disable Buttons -->
                            <div class="motor-controls-row">
                                <button class="btn-primary-modern" onclick="enableMotor(0)" style="flex: 1;">
                                    <i class="bi bi-power"></i> Enable
                                </button>
                                <button class="btn-secondary-modern" onclick="disableMotor(0)" style="flex: 1;">
                                    <i class="bi bi-stop-circle"></i> Disable
                                </button>
                            </div>

                            <!-- Tabs for Velocity/Position -->
                            <div class="tab-nav" style="margin-top: var(--space-4);">
                                <button class="tab-button active" onclick="switchMotorTab(0, 'velocity')">Velocity</button>
                                <button class="tab-button" onclick="switchMotorTab(0, 'position')">Position</button>
                            </div>

                            <!-- Velocity Tab for Motor 0 -->
                            <div id="motor0-tab-velocity" class="tab-content active">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">
                                        Velocity: <span id="motor0-velocityValue" style="color: var(--accent-blue);">0.0</span> t/s
                                    </label>
                                    <input type="range" class="form-range-modern" id="motor0-velocitySlider"
                                           min="-10" max="10" step="0.1" value="0"
                                           oninput="updateMotorVelocityDisplay(0, this.value)">
                                </div>
                                <button class="btn-primary-modern" style="width: 100%;" onclick="applyMotorVelocity(0)">
                                    <i class="bi bi-play-fill"></i> Apply Velocity
                                </button>
                            </div>

                            <!-- Position Tab for Motor 0 -->
                            <div id="motor0-tab-position" class="tab-content">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">Target Position (turns)</label>
                                    <div class="input-group">
                                        <input type="number" class="form-control form-input-modern" id="motor0-positionInput"
                                               placeholder="Enter position" step="0.1">
                                        <button class="btn btn-primary-modern" onclick="goToMotorPosition(0)">
                                            <i class="bi bi-arrow-right"></i> Go
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Position/Velocity Display -->
                            <div class="motor-value-display" style="margin-top: var(--space-4);">
                                <div class="value" id="motor0-position">0.000</div>
                                <div class="label">Position (turns)</div>
                            </div>
                            <div class="motor-value-display">
                                <div class="value" id="motor0-velocity">0.000</div>
                                <div class="label">Velocity (t/s)</div>
                            </div>

                            <!-- Health Section -->
                            <div style="margin-top: var(--space-4); padding-top: var(--space-3); border-top: 1px solid var(--border-color);">
                                <h6 style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: var(--space-3); text-transform: uppercase;">
                                    <i class="bi bi-activity"></i> Health
                                </h6>
                                <div class="motor-health-grid">
                                    <div class="motor-health-item">
                                        <div class="health-label">FET Temp</div>
                                        <div class="health-value" id="motor0-fet-temp">--Â°C</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Motor Temp</div>
                                        <div class="health-value" id="motor0-motor-temp">--Â°C</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Current (Iq)</div>
                                        <div class="health-value" id="motor0-iq">--A</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Power</div>
                                        <div class="health-value" id="motor0-power">--W</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Motor 1 Panel -->
                        <div class="motor-panel motor-panel-1">
                            <div class="motor-panel-header">
                                <div class="motor-panel-title">
                                    <i class="bi bi-gear-fill"></i>
                                    Motor 1
                                </div>
                            </div>

                            <!-- Motor State -->
                            <div class="motor-state-display">
                                <span id="motor1-state-icon" style="font-size: 1.2rem;">ðŸ”´</span>
                                <span class="motor-state-text" id="motor1-state">IDLE</span>
                            </div>

                            <!-- Enable/Disable Buttons -->
                            <div class="motor-controls-row">
                                <button class="btn-primary-modern" onclick="enableMotor(1)" style="flex: 1;">
                                    <i class="bi bi-power"></i> Enable
                                </button>
                                <button class="btn-secondary-modern" onclick="disableMotor(1)" style="flex: 1;">
                                    <i class="bi bi-stop-circle"></i> Disable
                                </button>
                            </div>

                            <!-- Tabs for Velocity/Position -->
                            <div class="tab-nav" style="margin-top: var(--space-4);">
                                <button class="tab-button active" onclick="switchMotorTab(1, 'velocity')">Velocity</button>
                                <button class="tab-button" onclick="switchMotorTab(1, 'position')">Position</button>
                            </div>

                            <!-- Velocity Tab for Motor 1 -->
                            <div id="motor1-tab-velocity" class="tab-content active">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">
                                        Velocity: <span id="motor1-velocityValue" style="color: rgb(188, 140, 255);">0.0</span> t/s
                                    </label>
                                    <input type="range" class="form-range-modern" id="motor1-velocitySlider"
                                           min="-10" max="10" step="0.1" value="0"
                                           oninput="updateMotorVelocityDisplay(1, this.value)">
                                </div>
                                <button class="btn-primary-modern" style="width: 100%;" onclick="applyMotorVelocity(1)">
                                    <i class="bi bi-play-fill"></i> Apply Velocity
                                </button>
                            </div>

                            <!-- Position Tab for Motor 1 -->
                            <div id="motor1-tab-position" class="tab-content">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">Target Position (turns)</label>
                                    <div class="input-group">
                                        <input type="number" class="form-control form-input-modern" id="motor1-positionInput"
                                               placeholder="Enter position" step="0.1">
                                        <button class="btn btn-primary-modern" onclick="goToMotorPosition(1)">
                                            <i class="bi bi-arrow-right"></i> Go
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Position/Velocity Display -->
                            <div class="motor-value-display" style="margin-top: var(--space-4);">
                                <div class="value" id="motor1-position">0.000</div>
                                <div class="label">Position (turns)</div>
                            </div>
                            <div class="motor-value-display">
                                <div class="value" id="motor1-velocity">0.000</div>
                                <div class="label">Velocity (t/s)</div>
                            </div>

                            <!-- Health Section -->
                            <div style="margin-top: var(--space-4); padding-top: var(--space-3); border-top: 1px solid var(--border-color);">
                                <h6 style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: var(--space-3); text-transform: uppercase;">
                                    <i class="bi bi-activity"></i> Health
                                </h6>
                                <div class="motor-health-grid">
                                    <div class="motor-health-item">
                                        <div class="health-label">FET Temp</div>
                                        <div class="health-value" id="motor1-fet-temp">--Â°C</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Motor Temp</div>
                                        <div class="health-value" id="motor1-motor-temp">--Â°C</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Current (Iq)</div>
                                        <div class="health-value" id="motor1-iq">--A</div>
                                    </div>
                                    <div class="motor-health-item">
                                        <div class="health-label">Power</div>
                                        <div class="health-value" id="motor1-power">--W</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Shared Bus Display -->
                    <div class="shared-bus-display">
                        <h6 style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: var(--space-3); text-transform: uppercase;">
                            <i class="bi bi-battery-charging"></i> Shared Bus (Both Motors)
                        </h6>
                        <div class="shared-bus-grid">
                            <div class="shared-bus-item">
                                <div class="bus-value" id="shared-bus-voltage">--</div>
                                <div class="bus-label">Voltage (V)</div>
                            </div>
                            <div class="shared-bus-item">
                                <div class="bus-value" id="shared-bus-current">--</div>
                                <div class="bus-label">Current (A)</div>
                            </div>
                            <div class="shared-bus-item">
                                <div class="bus-value" id="shared-bus-power">--</div>
                                <div class="bus-label">Power (W)</div>
                            </div>
                        </div>
                    </div>

                    <!-- Coordinated Control Panel (Initially Hidden) -->
                    <div id="coordinated-control-panel" style="display: none;">
                        <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-lg); padding: var(--space-4);">
                            <h5 style="margin-bottom: var(--space-4); color: var(--text-primary);">
                                <i class="bi bi-link-45deg"></i> Coordinated Multi-Motor Control
                            </h5>

                            <div class="form-group-modern">
                                <label class="form-label-modern">Joint 0 Position (turns)</label>
                                <input type="number" class="form-control form-input-modern" id="coord-joint0"
                                       placeholder="Motor 0 position" step="0.1">
                            </div>

                            <div class="form-group-modern">
                                <label class="form-label-modern">Joint 1 Position (turns)</label>
                                <input type="number" class="form-control form-input-modern" id="coord-joint1"
                                       placeholder="Motor 1 position" step="0.1">
                            </div>

                            <div class="btn-group-modern">
                                <button class="btn-primary-modern" onclick="applyCoordinatedPosition()" style="flex: 1;">
                                    <i class="bi bi-play-fill"></i> Execute SETALL
                                </button>
                                <button class="btn-danger-modern" onclick="stopAllMotors()">
                                    <i class="bi bi-stop-fill"></i> Stop All
                                </button>
                            </div>

                            <div style="margin-top: var(--space-3); padding: var(--space-2); background: var(--bg-secondary); border-radius: var(--radius-sm); font-size: 0.8rem; color: var(--text-muted);">
                                <i class="bi bi-info-circle"></i> Coordinated mode sends both positions simultaneously using the SETALL command.
                            </div>
                        </div>
                    </div>

                    <!-- OLD Single Motor Controls (Hidden for now, can be removed later) -->
                    <div style="display: none;">
                    <!-- Motor Enable/Disable Controls -->
                    <div style="padding: var(--space-4); background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: var(--space-3); flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: var(--space-2);">
                                    <i class="bi bi-power"></i> Motor State
                                </div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary);">
                                    <span id="motorStateDisplay">IDLE</span>
                                    <span id="motorStateIcon" style="margin-left: var(--space-2); font-size: 0.9rem;">ðŸ”´</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: var(--space-2);">
                                <button class="btn-primary-modern" onclick="enableMotor()" id="enableButton">
                                    <i class="bi bi-power"></i> Enable Motor
                                </button>
                                <button class="btn-secondary-modern" onclick="disableMotor()" id="disableButton">
                                    <i class="bi bi-stop-circle"></i> Disable Motor
                                </button>
                            </div>
                        </div>
                        <div style="margin-top: var(--space-2); padding: var(--space-2); background: var(--bg-tertiary); border-radius: var(--radius-sm); font-size: 0.8rem; color: var(--text-muted);">
                            <i class="bi bi-info-circle"></i>
                            <strong>Enable</strong> clears errors and calibrates the motor (~6 seconds).
                            <strong>Disable</strong> stops motor and enters idle mode.
                        </div>
                    </div>

                    <!-- Control Tabs -->
                    <div class="tab-nav">
                        <button class="tab-button active" onclick="switchTab('velocity')">Velocity</button>
                        <button class="tab-button" onclick="switchTab('position')">Position</button>
                        <button class="tab-button" onclick="switchTab('presets')">Presets & Waypoints</button>
                        <button class="tab-button" onclick="switchTab('recording')">Recording</button>
                    </div>
                    
                    <!-- Velocity Tab -->
                    <div id="tab-velocity" class="tab-content active">
                        <div class="form-group-modern">
                            <label class="form-label-modern">
                                Velocity: <span id="velocityValue" style="color: var(--accent-blue);">0.0</span> turns/sec
                            </label>
                            <input type="range" class="form-range-modern" id="velocitySlider"
                                   min="-10" max="10" step="0.1" value="0"
                                   oninput="updateVelocityDisplay(this.value)">
                        </div>
                        
                        <div class="form-group-modern">
                            <label class="form-label-modern">Preset Speeds</label>
                            <div class="btn-group-modern">
                                <button class="btn-secondary-modern" onclick="setVelocity(-10)">-10</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(-5)">-5</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(-1)">-1</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(0)">0</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(1)">+1</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(5)">+5</button>
                                <button class="btn-secondary-modern" onclick="setVelocity(10)">+10</button>
                            </div>
                        </div>
                        
                        <div class="btn-group-modern">
                            <button class="btn-primary-modern" style="flex: 1;" onclick="applyVelocity()">
                                <i class="bi bi-play-fill"></i> Apply Velocity
                            </button>
                            <button class="btn-danger-modern" onclick="emergencyStop()">
                                <i class="bi bi-stop-fill"></i> Stop
                            </button>
                        </div>
                        
                        <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">
                        
                        <details style="margin-top: var(--space-4);">
                            <summary style="cursor: pointer; font-weight: 500; color: var(--text-primary); margin-bottom: var(--space-4);">
                                <i class="bi bi-chevron-right"></i> Advanced Settings
                            </summary>
                            
                            <div class="form-group-modern">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--space-2);">
                                    <label class="form-label-modern" style="margin: 0;">Velocity Ramping</label>
                                    <label class="form-check form-switch">
                                        <input class="form-check-input" type="checkbox" id="velocityRampingEnabled" checked
                                               onchange="toggleVelocityRamping(this.checked)">
                                    </label>
                                </div>
                                <small style="color: var(--text-muted);">Smooth acceleration and deceleration</small>
                            </div>
                            
                            <div id="velocityRampingControls">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">
                                        Acceleration: <span id="accelerationValue">5.0</span> turns/secÂ²
                                    </label>
                                    <input type="range" class="form-range-modern" id="accelerationLimit"
                                           min="0.5" max="20" step="0.5" value="5"
                                           oninput="updateAccelerationDisplay(this.value)">
                                </div>
                                
                                <div class="form-group-modern">
                                    <label class="form-label-modern">
                                        Deceleration: <span id="decelerationValue">5.0</span> turns/secÂ²
                                    </label>
                                    <input type="range" class="form-range-modern" id="decelerationLimit"
                                           min="0.5" max="20" step="0.5" value="5"
                                           oninput="updateDecelerationDisplay(this.value)">
                                </div>
                            </div>
                        </details>
                    </div>
                    
                    <!-- Position Tab -->
                    <div id="tab-position" class="tab-content">
                        <div class="form-group-modern">
                            <label class="form-label-modern">Target Position (turns)</label>
                            <div class="input-group">
                                <input type="number" class="form-control form-input-modern" id="positionInput"
                                       placeholder="Enter position" step="0.1" style="border-radius: var(--radius-md) 0 0 var(--radius-md);">
                                <button class="btn btn-primary-modern" onclick="goToPosition()" style="border-radius: 0 var(--radius-md) var(--radius-md) 0;">
                                    <i class="bi bi-arrow-right"></i> Go
                                </button>
                            </div>
                        </div>
                        
                        <div class="form-group-modern">
                            <label class="form-label-modern">
                                Position Scale Factor: <span id="scaleFactorValue">1.0</span>x
                            </label>
                            <input type="range" class="form-range-modern" id="positionScaleFactor"
                                   min="0.1" max="20" step="0.1" value="1.0"
                                   oninput="updateScaleFactorDisplay(this.value)">
                            <small style="color: var(--text-muted);">Adjust if motor doesn't rotate correctly</small>
                        </div>
                        
                        <div class="form-group-modern">
                            <button id="startCalibrationBtn" class="btn-secondary-modern" style="width: 100%;" onclick="startCalibration()">
                                <i class="bi bi-tools"></i> Auto-Calibrate Scale Factor
                            </button>
                            <div id="calibrationProgress" style="display: none; margin-top: var(--space-3);">
                                <div class="progress">
                                    <div id="calibrationProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                                         role="progressbar" style="width: 0%"></div>
                                </div>
                                <small id="calibrationStatus" style="color: var(--text-muted); display: block; margin-top: var(--space-2);">Initializing...</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Presets & Waypoints Tab -->
                    <div id="tab-presets" class="tab-content">
                        <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">Position Presets</h6>
                        <div id="presetsList" style="display: flex; flex-wrap: wrap; gap: var(--space-2); margin-bottom: var(--space-4);">
                            <!-- Dynamically populated -->
                        </div>
                        <div class="btn-group-modern">
                            <button class="btn-success-modern" onclick="saveCurrentAsPreset()">
                                <i class="bi bi-bookmark-plus"></i> Save Current
                            </button>
                            <button class="btn-secondary-modern" onclick="openPresetManager()">
                                <i class="bi bi-gear"></i> Manage
                            </button>
                        </div>
                        
                        <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">
                        
                        <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">Waypoint Sequences</h6>
                        <div class="form-group-modern">
                            <select id="waypointSelect" class="form-select form-control">
                                <option value="">-- Select Waypoint --</option>
                            </select>
                        </div>
                        <div class="btn-group-modern">
                            <button class="btn-primary-modern" onclick="executeWaypoint()" id="executeWaypointBtn">
                                <i class="bi bi-play-fill"></i> Execute
                            </button>
                            <button class="btn-danger-modern" onclick="stopWaypoint()" id="stopWaypointBtn" disabled>
                                <i class="bi bi-stop-fill"></i> Stop
                            </button>
                            <button class="btn-secondary-modern" onclick="openWaypointBuilder()">
                                <i class="bi bi-plus-circle"></i> Create
                            </button>
                        </div>
                    </div>
                    
                    <!-- Recording Tab -->
                    <div id="tab-recording" class="tab-content">
                        <div class="form-group-modern">
                            <label class="form-label-modern">Recording Controls</label>
                            <div class="btn-group-modern">
                                <button class="btn-danger-modern" onclick="startRecording()" id="startRecordingBtn">
                                    <i class="bi bi-record-circle"></i> Record
                                </button>
                                <button class="btn-secondary-modern" onclick="stopRecording()" id="stopRecordingBtn" disabled>
                                    <i class="bi bi-stop-circle"></i> Stop
                                </button>
                            </div>
                            <div id="recordingIndicator" style="display: none; margin-top: var(--space-3);">
                                <div class="alert alert-danger">
                                    <i class="bi bi-record-fill blink"></i> Recording... <span id="recordingDuration">0:00</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group-modern">
                            <label class="form-label-modern">Sequence Library</label>
                            <select id="sequenceSelect" class="form-select form-control">
                                <option value="">-- Select Sequence --</option>
                            </select>
                        </div>
                        
                        <div class="btn-group-modern">
                            <button class="btn-success-modern" onclick="playSequence()" id="playSequenceBtn">
                                <i class="bi bi-play-fill"></i> Play
                            </button>
                            <button class="btn-secondary-modern" onclick="pauseSequence()" id="pauseSequenceBtn" disabled>
                                <i class="bi bi-pause-fill"></i> Pause
                            </button>
                            <button class="btn-danger-modern" onclick="stopSequence()" id="stopSequenceBtn" disabled>
                                <i class="bi bi-stop-fill"></i> Stop
                            </button>
                        </div>
                        
                        <div id="playbackProgress" style="display: none; margin-top: var(--space-3);">
                            <div class="progress" style="height: 8px;">
                                <div id="playbackProgressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small style="color: var(--text-muted); display: block; margin-top: var(--space-2);">
                                <span id="playbackTime">0:00</span> / <span id="playbackDuration">0:00</span>
                                <span id="playbackSpeed" style="float: right;">1.0x</span>
                            </small>
                        </div>
                        
                        <div class="form-group-modern">
                            <label class="form-label-modern">
                                Playback Speed: <span id="playbackSpeedValue">1.0</span>x
                            </label>
                            <input type="range" class="form-range-modern" id="playbackSpeedSlider"
                                   min="0.1" max="3.0" step="0.1" value="1.0"
                                   oninput="updatePlaybackSpeed(this.value)">
                        </div>
                        
                        <div class="btn-group-modern">
                            <button class="btn-secondary-modern" onclick="openSequenceLibrary()">
                                <i class="bi bi-folder"></i> Library
                            </button>
                            <button class="btn-danger-modern" onclick="deleteSequence()">
                                <i class="bi bi-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                    </div>
                    <!-- End hidden OLD single motor controls -->
                </div>
            </div>

            <!-- Joystick Mode -->
            <div id="mode-joystick" class="mode-section" style="display: none;">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-controller"></i>
                        <h2>Joystick Control</h2>
                    </div>
                    
                    <div style="text-align: center;">
                        <canvas id="joystickCanvas" width="400" height="400"></canvas>
                        <div style="margin-top: var(--space-4);">
                            <span style="color: var(--text-secondary);">Angle: <strong id="joystickAngle" style="color: var(--accent-blue);">0.0Â°</strong></span>
                            <span style="margin-left: var(--space-4); color: var(--text-secondary);">Position: <strong id="joystickPosition" style="color: var(--accent-green);">0.000</strong> turns</span>
                        </div>
                        <div style="margin-top: var(--space-3);">
                            <label class="form-check">
                                <input class="form-check-input" type="checkbox" id="joystickHoldPosition" checked>
                                <span style="color: var(--text-primary);">Hold position on release</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Rotation Mode -->
            <div id="mode-rotation" class="mode-section" style="display: none;">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-disc"></i>
                        <h2>Rotation Knob Control</h2>
                    </div>
                    
                    <div id="rotationKnobContainer" style="text-align: center;">
                        <!-- SVG knob created by JavaScript -->
                    </div>
                    
                    <div style="text-align: center; margin-top: var(--space-4);">
                        <div style="margin-bottom: var(--space-2);">
                            <strong style="color: var(--text-primary);">Position:</strong> 
                            <span id="rotationDegrees" style="color: var(--accent-blue);">0</span>Â° 
                            (<span id="rotationTurns" style="color: var(--accent-green);">0.000</span> turns)
                        </div>
                        <div>
                            <small style="color: var(--text-muted);">Rotations: <span id="rotationCount">0</span></small>
                        </div>
                    </div>
                    
                    <div class="btn-group-modern" style="margin-top: var(--space-4);">
                        <button class="btn-secondary-modern" onclick="setRotationZero()">
                            <i class="bi bi-bullseye"></i> Set Current as Zero
                        </button>
                        <button class="btn-primary-modern" onclick="resetRotationToZero()">
                            <i class="bi bi-arrow-clockwise"></i> Return to Zero
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- IK Mode -->
            <div id="mode-ik" class="mode-section" style="display: none;">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-robot"></i>
                        <h2>Inverse Kinematics Control</h2>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-6);">
                        <div>
                            <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">Robot Visualizer</h6>
                            <div style="border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--space-3); background: var(--bg-tertiary);">
                                <canvas id="robotCanvas" width="400" height="400"></canvas>
                            </div>
                            <div style="margin-top: var(--space-3); text-align: center;">
                                <small id="endEffectorPos" style="color: var(--text-muted);">End Effector: (0.000, 0.000) m</small>
                            </div>
                        </div>
                        
                        <div>
                            <div class="form-group-modern">
                                <label class="form-label-modern">Robot Configuration</label>
                                <select id="robotConfigSelect" class="form-select form-control">
                                    <option value="single">Single Motor (Current)</option>
                                    <option value="2dof">2-DOF Test</option>
                                    <option value="3dof">3-DOF Test (Phase 2)</option>
                                    <option value="6dof">6-DOF Full Arm (Phase 3)</option>
                                </select>
                                <small style="color: var(--text-muted);">Select configuration and upload appropriate Arduino sketch</small>
                            </div>
                            
                            <h6 style="margin: var(--space-4) 0; color: var(--text-primary);">Joint Angles</h6>
                            <div id="jointSliders">
                                <div class="form-group-modern">
                                    <label class="form-label-modern">J0: <span id="joint0Value">0.000</span> rad</label>
                                    <input type="range" class="form-range-modern" id="joint0Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                                <div class="form-group-modern">
                                    <label class="form-label-modern">J1: <span id="joint1Value">0.000</span> rad</label>
                                    <input type="range" class="form-range-modern" id="joint1Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                                <div class="form-group-modern" id="joint2Container" style="display: none;">
                                    <label class="form-label-modern">J2: <span id="joint2Value">0.000</span> rad</label>
                                    <input type="range" class="form-range-modern" id="joint2Slider"
                                           min="-3.14" max="3.14" step="0.01" value="0">
                                </div>
                            </div>
                            <button class="btn-primary-modern" style="width: 100%;" onclick="setJointAngles()">
                                <i class="bi bi-check-circle"></i> Set Joint Angles
                            </button>
                            
                            <div id="cartesianControls" style="display: none; margin-top: var(--space-6);">
                                <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">Cartesian Target</h6>
                                <div class="form-group-modern">
                                    <label class="form-label-modern">X: <span id="targetX">0.300</span> m</label>
                                    <input type="range" class="form-range-modern" id="xSlider"
                                           min="-0.6" max="0.6" step="0.01" value="0.3">
                                </div>
                                <div class="form-group-modern">
                                    <label class="form-label-modern">Y: <span id="targetY">0.000</span> m</label>
                                    <input type="range" class="form-range-modern" id="ySlider"
                                           min="-0.6" max="0.6" step="0.01" value="0.0">
                                </div>
                                <div class="form-group-modern">
                                    <label class="form-label-modern">Z: <span id="targetZ">0.400</span> m</label>
                                    <input type="range" class="form-range-modern" id="zSlider"
                                           min="0.0" max="0.8" step="0.01" value="0.4">
                                </div>
                                <button class="btn-success-modern" style="width: 100%;" onclick="moveToCartesianTarget()">
                                    <i class="bi bi-geo-alt"></i> Move to Cartesian Target
                                </button>
                                <div style="text-align: center; margin-top: var(--space-3);">
                                    <small>IK Status: <span id="ikStatus" class="badge bg-secondary">Phase 2</span></small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Monitoring Mode -->
            <div id="mode-monitor" class="mode-section" style="display: none;">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-graph-up"></i>
                        <h2>Real-Time Monitoring</h2>
                    </div>
                    
                    <!-- Status Grid -->
                    <div class="status-grid">
                        <div class="value-display-modern">
                            <div class="value" id="currentPosition">0.000</div>
                            <div class="label">Position (turns)</div>
                        </div>
                        <div class="value-display-modern">
                            <div class="value" id="currentVelocity">0.000</div>
                            <div class="label">Velocity (turns/sec)</div>
                        </div>
                    </div>
                    
                    <!-- Charts -->
                    <h6 style="margin-top: var(--space-6); margin-bottom: var(--space-4); color: var(--text-primary);">Position History</h6>
                    <div class="chart-container-modern">
                        <canvas id="positionChart"></canvas>
                    </div>
                    
                    <h6 style="margin-top: var(--space-6); margin-bottom: var(--space-4); color: var(--text-primary);">Velocity History</h6>
                    <div class="chart-container-modern">
                        <canvas id="velocityChart"></canvas>
                    </div>
                    
                    <!-- Health Monitor -->
                    <h6 style="margin-top: var(--space-6); margin-bottom: var(--space-4); color: var(--text-primary);">
                        <i class="bi bi-heart-pulse"></i> Health Monitor
                    </h6>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-4);">
                        <div class="status-item">
                            <div class="status-item-label">Connection</div>
                            <div class="status-item-value">
                                <span class="badge" id="healthConnection">Checking...</span>
                            </div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-label">Feedback Rate</div>
                            <div class="status-item-value" id="healthFeedbackRate">-- Hz</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-label">Control Mode</div>
                            <div class="status-item-value" id="healthControlMode">--</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-label">Errors</div>
                            <div class="status-item-value">
                                <span class="badge bg-success" id="healthErrors">None</span>
                            </div>
                        </div>
                    </div>

                    <!-- Power & Battery Monitoring -->
                    <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">

                    <h6 style="margin-bottom: var(--space-3); color: var(--text-primary);">
                        <i class="bi bi-battery-charging"></i> Power & Battery
                    </h6>

                    <div class="row g-3">
                        <!-- Voltage Display -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">Bus Voltage</div>
                                <div class="metric-value">
                                    <span id="healthVoltage">--</span> V
                                </div>
                                <div class="metric-status" id="voltageStatus">
                                    <span class="badge bg-secondary">No Data</span>
                                </div>
                            </div>
                        </div>

                        <!-- Current Display -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">Bus Current</div>
                                <div class="metric-value">
                                    <span id="healthCurrent">--</span> A
                                </div>
                                <div class="metric-status" id="currentStatus">
                                    <span class="badge bg-secondary">No Data</span>
                                </div>
                            </div>
                        </div>

                        <!-- Power Display -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">Power Draw</div>
                                <div class="metric-value">
                                    <span id="healthPower">--</span> W
                                </div>
                                <div class="metric-status">
                                    <small id="powerEfficiency" style="color: var(--text-muted);">--</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Temperature Section -->
                    <h6 style="margin: var(--space-4) 0 var(--space-3); color: var(--text-primary);">
                        <i class="bi bi-thermometer-half"></i> Temperatures
                    </h6>

                    <div class="row g-3">
                        <!-- FET Temperature -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">FET (Electronics)</div>
                                <div class="metric-value">
                                    <span id="healthFetTemp">--</span> Â°C
                                </div>
                                <div class="metric-status" id="fetTempStatus">
                                    <span class="badge bg-secondary">No Data</span>
                                </div>
                            </div>
                        </div>

                        <!-- Motor Temperature -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">Motor (Coils)</div>
                                <div class="metric-value">
                                    <span id="healthMotorTemp">--</span> Â°C
                                </div>
                                <div class="metric-status" id="motorTempStatus">
                                    <span class="badge bg-secondary">No Data</span>
                                </div>
                            </div>
                        </div>

                        <!-- Motor Current -->
                        <div class="col-md-4">
                            <div class="metric-card">
                                <div class="metric-label">Motor Current (Iq)</div>
                                <div class="metric-value">
                                    <span id="healthIqMeasured">--</span> A
                                </div>
                                <div class="metric-status">
                                    <small id="iqSetpoint" style="color: var(--text-muted);">
                                        Target: <span id="healthIqSetpoint">--</span> A
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- System Log -->
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-terminal"></i>
                        <h2>System Log</h2>
                    </div>
                    <div class="log-container" id="logMessages"></div>
                </div>
            </div>
            
            <!-- Advanced Mode -->
            <div id="mode-advanced" class="mode-section" style="display: none;">
                <div class="card-modern">
                    <div class="card-header-modern">
                        <i class="bi bi-gear"></i>
                        <h2>Advanced Settings</h2>
                    </div>
                    
                    <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">Gamepad Controller</h6>
                    <div id="gamepadStatus" class="alert alert-sm">
                        <i class="bi bi-controller"></i> <span id="gamepadStatusText">No gamepad detected</span>
                    </div>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="gamepadEnabled">
                        <label class="form-check-label" for="gamepadEnabled">Enable Gamepad Control</label>
                    </div>
                    <div id="gamepadControls" style="display: none; margin-top: var(--space-3);">
                        <small style="color: var(--text-secondary);">
                            <strong>Controls:</strong><br>
                            â€¢ Left Stick: Velocity Control<br>
                            â€¢ A: Stop | B: Zero Position<br>
                            â€¢ X: Play Sequence | Y: Record<br>
                            â€¢ Start: Emergency Stop<br>
                            â€¢ D-Pad: Adjust Presets<br>
                            â€¢ Triggers: Fine Velocity
                        </small>
                    </div>
                    
                    <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">

                    <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">
                        <i class="bi bi-gear-wide"></i> Control Mode Settings
                    </h6>

                    <div class="alert alert-sm" style="font-size: 0.85rem; padding: 0.5rem; margin-bottom: var(--space-3);">
                        <i class="bi bi-info-circle"></i> Advanced users only. Normal operation switches modes automatically.
                    </div>

                    <div class="form-group-modern">
                        <label class="form-label-modern">Control Mode</label>
                        <select id="controlModeSelect" class="form-select form-control">
                            <option value="0">VOLTAGE_CONTROL</option>
                            <option value="1">TORQUE_CONTROL</option>
                            <option value="2" selected>VELOCITY_CONTROL</option>
                            <option value="3">POSITION_CONTROL</option>
                        </select>
                    </div>

                    <div class="form-group-modern">
                        <label class="form-label-modern">Input Mode</label>
                        <select id="inputModeSelect" class="form-select form-control">
                            <option value="0">INACTIVE</option>
                            <option value="1">PASSTHROUGH</option>
                            <option value="2" selected>VEL_RAMP</option>
                            <option value="3">POS_FILTER</option>
                            <option value="4">MIX_CHANNELS</option>
                            <option value="5">TRAP_TRAJ</option>
                            <option value="6">TORQUE_RAMP</option>
                            <option value="7">MIRROR</option>
                            <option value="8">TUNING</option>
                        </select>
                    </div>

                    <button class="btn-primary-modern" style="width: 100%;" onclick="setControlMode()">
                        <i class="bi bi-arrow-repeat"></i> Apply Control Mode
                    </button>

                    <button class="btn-secondary-modern" style="width: 100%; margin-top: var(--space-2);" onclick="clearSavedControlMode()">
                        <i class="bi bi-x-circle"></i> Clear Saved Mode
                    </button>

                    <div style="margin-top: var(--space-3);">
                        <small style="color: var(--text-muted);">
                            <strong>Common Combinations:</strong><br>
                            â€¢ Velocity: Control=2 (VELOCITY) + Input=2 (VEL_RAMP)<br>
                            â€¢ Position: Control=3 (POSITION) + Input=3 (POS_FILTER)<br>
                            <br>
                            <strong style="color: var(--accent-yellow);">âš ï¸ For Rotation Knob:</strong><br>
                            â€¢ Best: <strong>TRAP_TRAJ (5)</strong> - Smoothest tracking with trajectory planning<br>
                            â€¢ Good: <strong>POS_FILTER (3)</strong> - Filtered but may lag during continuous motion<br>
                            â€¢ Avoid: <strong>PASSTHROUGH (1)</strong> - No filtering, causes jitter<br>
                            <br>
                            <strong style="color: var(--accent-orange);">âš ï¸ Position Control Accuracy:</strong><br>
                            â€¢ Best: <strong>TRAP_TRAJ (5)</strong> - Smooth trajectories with excellent settling<br>
                            â€¢ Good: <strong>POS_FILTER (3)</strong> - Filtered but may cause ringing/oscillation near zero<br>
                            â€¢ Avoid: <strong>PASSTHROUGH (1)</strong> - No filtering, causes jitter<br>
                            <span style="font-style: italic;">If you experience oscillation when commanding zero position, switch to TRAP_TRAJ mode.</span>
                        </small>
                    </div>

                    <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">

                    <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">
                        <i class="bi bi-broadcast"></i> CAN Bus Configuration
                    </h6>

                    <div class="alert alert-sm" style="font-size: 0.85rem; padding: 0.5rem; margin-bottom: var(--space-3);">
                        <i class="bi bi-info-circle"></i> Both motors communicate via CAN bus at 250kbps. Each ODrive must have a unique node ID.
                    </div>

                    <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--space-4); margin-bottom: var(--space-3);">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-4); margin-bottom: var(--space-3);">
                            <!-- Motor 0 CAN Info -->
                            <div>
                                <h6 style="font-size: 0.85rem; color: var(--accent-blue); margin-bottom: var(--space-2);">
                                    <i class="bi bi-gear-fill"></i> Motor 0
                                </h6>
                                <div style="font-size: 0.9rem; color: var(--text-primary);">
                                    <strong>CAN Node ID:</strong> <span style="font-family: 'Courier New', monospace; color: var(--accent-blue);">1</span>
                                </div>
                                <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: var(--space-1);">
                                    Primary motor
                                </div>
                            </div>

                            <!-- Motor 1 CAN Info -->
                            <div>
                                <h6 style="font-size: 0.85rem; color: rgb(188, 140, 255); margin-bottom: var(--space-2);">
                                    <i class="bi bi-gear-fill"></i> Motor 1
                                </h6>
                                <div style="font-size: 0.9rem; color: var(--text-primary);">
                                    <strong>CAN Node ID:</strong> <span style="font-family: 'Courier New', monospace; color: rgb(188, 140, 255);">2</span>
                                </div>
                                <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: var(--space-1);">
                                    Secondary motor
                                </div>
                            </div>
                        </div>

                        <div style="background: var(--bg-secondary); padding: var(--space-3); border-radius: var(--radius-sm);">
                            <h6 style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: var(--space-2); text-transform: uppercase;">
                                CAN Bus Parameters
                            </h6>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-2);">
                                <div>
                                    <strong>Baudrate:</strong> 250000 bps
                                </div>
                                <div>
                                    <strong>Protocol:</strong> Simple CAN
                                </div>
                                <div>
                                    <strong>Update Rate:</strong> 100ms
                                </div>
                                <div>
                                    <strong>Interface:</strong> Arduino R4 CAN
                                </div>
                            </div>
                        </div>
                    </div>

                    <details style="margin-bottom: var(--space-4);">
                        <summary style="cursor: pointer; font-weight: 500; color: var(--text-primary); padding: var(--space-2); background: var(--bg-tertiary); border-radius: var(--radius-sm);">
                            <i class="bi bi-chevron-right"></i> How to Configure CAN Node IDs
                        </summary>
                        <div style="margin-top: var(--space-3); padding: var(--space-3); background: var(--bg-tertiary); border-radius: var(--radius-sm); font-size: 0.85rem; color: var(--text-secondary);">
                            <p style="margin-bottom: var(--space-2);"><strong>Step 1: Connect to ODrive via USB</strong></p>
                            <pre style="background: var(--bg-primary); padding: var(--space-2); border-radius: var(--radius-sm); overflow-x: auto;">python3
import odrive
odrv0 = odrive.find_any()  # First ODrive</pre>

                            <p style="margin-top: var(--space-3); margin-bottom: var(--space-2);"><strong>Step 2: Configure Node ID</strong></p>
                            <pre style="background: var(--bg-primary); padding: var(--space-2); border-radius: var(--radius-sm); overflow-x: auto;"># For Motor 0 (Node ID 1)
odrv0.axis0.config.can.node_id = 1
odrv0.save_configuration()
odrv0.reboot()

# For Motor 1 (Node ID 2)
odrv1 = odrive.find_any()  # Second ODrive
odrv1.axis0.config.can.node_id = 2
odrv1.save_configuration()
odrv1.reboot()</pre>

                            <p style="margin-top: var(--space-3); margin-bottom: var(--space-2);"><strong>Step 3: Verify Configuration</strong></p>
                            <pre style="background: var(--bg-primary); padding: var(--space-2); border-radius: var(--radius-sm); overflow-x: auto;"># Check heartbeat messages on Arduino serial monitor
# Both motors should appear on CAN bus after configuration</pre>

                            <div style="margin-top: var(--space-3); padding: var(--space-2); background: var(--bg-secondary); border-left: 3px solid var(--accent-yellow); border-radius: var(--radius-sm);">
                                <i class="bi bi-exclamation-triangle"></i> <strong>Important:</strong> Each ODrive on the same CAN bus must have a unique node ID. Duplicate IDs will cause communication conflicts.
                            </div>
                        </div>
                    </details>

                    <hr style="border-color: var(--border-color); margin: var(--space-6) 0;">

                    <h6 style="margin-bottom: var(--space-4); color: var(--text-primary);">System Information</h6>
                    <table class="table table-sm">
                        <tbody>
                            <tr>
                                <td><strong>Serial Port:</strong></td>
                                <td><span id="healthSerial">/dev/ttyACM1</span></td>
                            </tr>
                            <tr>
                                <td><strong>Last Update:</strong></td>
                                <td><span id="healthLastUpdate">--</span></td>
                            </tr>
                            <tr>
                                <td><strong>Motor State:</strong></td>
                                <td><span id="motorState">Unknown</span></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    </div>

    <!-- Persistent Bottom Log Panel -->
    <div id="persistentLogPanel" class="persistent-log-panel collapsed">
        <div class="log-panel-header" onclick="toggleLogPanel()">
            <div class="log-panel-title">
                <i class="bi bi-terminal" id="logPanelIcon"></i>
                <span>System Log</span>
                <span id="logPanelBadge" class="badge bg-secondary ms-2">0</span>
            </div>
            <button class="log-panel-toggle" onclick="toggleLogPanel(); event.stopPropagation();">
                <i class="bi bi-chevron-up" id="logPanelChevron"></i>
            </button>
        </div>
        <div class="log-panel-content" id="persistentLogContent">
            <!-- Logs appear here -->
        </div>
    </div>

    <!-- Modals (existing ones from original file) -->
    <!-- Preset Manager Modal -->
    <div class="modal fade" id="presetManagerModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Manage Position Presets</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="presetManagerList">
                        <!-- Dynamically populated list -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Waypoint Builder Modal -->
    <div class="modal fade" id="waypointBuilderModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Create Waypoint Sequence</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">Waypoint Name</label>
                        <input type="text" class="form-control" id="waypointName" placeholder="e.g., Calibration Sequence">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Positions (turns)</label>
                        <div id="waypointPositionsList" class="mb-2">
                            <!-- Dynamically added position inputs -->
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addWaypointPosition()">
                            + Add Position
                        </button>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Pause Duration (ms)</label>
                        <input type="number" class="form-control" id="waypointPauseDuration" value="1000" min="0" step="100">
                    </div>
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="waypointLoop">
                        <label class="form-check-label" for="waypointLoop">Loop sequence</label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveWaypoint()">Save Waypoint</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Modal -->
    <div class="modal fade" id="shortcutHelpModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Keyboard Shortcuts</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <strong>Note:</strong> Keyboard shortcuts work when not typing in input fields.
                    </div>
                    <div id="shortcutHelpContent">
                        <!-- Dynamically populated by KeyboardShortcutManager -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="keyboardShortcutManager.toggle(); updateShortcutsToggleUI();">
                        <span id="toggleShortcutsText">Disable Shortcuts</span>
                    </button>
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Calibration Results Modal -->
    <div class="modal fade" id="calibrationResultsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Calibration Results</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="calibrationResultsContent">
                        <!-- Dynamically populated by CalibrationExecutor -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="applyCalibrationBtn" onclick="applyCalibrationResults()">
                        Apply Recommended Scale Factor
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Sequence Library Modal -->
    <div class="modal fade" id="sequenceLibraryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Sequence Library</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="sequenceLibraryList">
                        <!-- Dynamically populated sequence list -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for persistent log panel
        let logCount = 0;
        const maxPersistentLogs = 100;

        // Mode and Tab Switching Functions
        function switchMode(mode) {
            // Hide all mode sections
            document.querySelectorAll('.mode-section').forEach(el => el.style.display = 'none');
            // Show selected mode
            document.getElementById('mode-' + mode).style.display = 'block';

            // Update sidebar navigation
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.getElementById('nav-' + mode).classList.add('active');
        }

        // Multi-motor control mode management
        let multiMotorControlMode = 'independent'; // Default to independent mode

        function setMultiMotorControlMode(mode) {
            multiMotorControlMode = mode;

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            if (mode === 'independent') {
                document.getElementById('btnIndependentMode').classList.add('active');
            } else {
                document.getElementById('btnCoordinatedMode').classList.add('active');
            }

            // Toggle UI visibility (motor panels vs coordinated panel)
            const motorPanels = document.querySelectorAll('.motor-panel');
            const coordinatedPanel = document.getElementById('coordinated-control-panel');

            if (mode === 'independent') {
                motorPanels.forEach(panel => panel.style.display = 'block');
                if (coordinatedPanel) coordinatedPanel.style.display = 'none';
            } else {
                motorPanels.forEach(panel => panel.style.display = 'none');
                if (coordinatedPanel) coordinatedPanel.style.display = 'block';
            }
        }

        function switchTab(tab) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            // Show selected tab
            document.getElementById('tab-' + tab).classList.add('active');
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        // Update sidebar quick info
        function updateSidebarInfo(position, velocity) {
            if (document.getElementById('sidebarPosition')) {
                document.getElementById('sidebarPosition').textContent = position.toFixed(3);
            }
            if (document.getElementById('sidebarVelocity')) {
                document.getElementById('sidebarVelocity').textContent = velocity.toFixed(3);
            }
        }
        
        // Initialize details/summary toggle icons
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('details').forEach(details => {
                details.addEventListener('toggle', function() {
                    const icon = this.querySelector('summary i');
                    if (icon) {
                        icon.className = this.open ? 'bi bi-chevron-down' : 'bi bi-chevron-right';
                    }
                });
            });
        });

        // Socket.IO connection with explicit configuration
        const socket = io({
            reconnection: true,
            reconnectionDelay: 1000,        // Wait 1 second before first reconnect
            reconnectionDelayMax: 5000,     // Max 5 seconds between reconnects
            reconnectionAttempts: Infinity, // Keep trying forever
            timeout: 20000,                 // Connection timeout: 20 seconds
            transports: ['websocket', 'polling']  // Prefer WebSocket, fallback to polling
        });

        // Position scaling factor (to compensate for ODrive encoder config)
        let positionScaleFactor = 1.0;  // Default 1.0x for direct motor control

        function updateScaleFactorDisplay(value) {
            positionScaleFactor = parseFloat(value);
            document.getElementById('scaleFactorValue').textContent = value;
            localStorage.setItem('positionScaleFactor', value);  // Persist setting
            addLog(`Position scale factor set to ${value}x`, 'info');
        }

        // Chart.js setup - Multi-Motor Support
        const maxDataPoints = 100;
        let positionDataMotor0 = [];
        let positionDataMotor1 = [];
        let velocityDataMotor0 = [];
        let velocityDataMotor1 = [];
        let timeLabels = [];

        // Legacy single-motor arrays (for backward compatibility)
        let positionData = [];
        let velocityData = [];

        // Position Chart - Dual Motor
        const positionCtx = document.getElementById('positionChart').getContext('2d');
        const positionChart = new Chart(positionCtx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Motor 0 Position (turns)',
                        data: positionDataMotor0,
                        borderColor: 'rgb(88, 166, 255)',  // Blue
                        backgroundColor: 'rgba(88, 166, 255, 0.1)',
                        tension: 0.1,
                        borderWidth: 2
                    },
                    {
                        label: 'Motor 1 Position (turns)',
                        data: positionDataMotor1,
                        borderColor: 'rgb(188, 140, 255)',  // Purple
                        backgroundColor: 'rgba(188, 140, 255, 0.1)',
                        tension: 0.1,
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Position (turns)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    }
                },
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });

        // Velocity Chart - Dual Motor
        const velocityCtx = document.getElementById('velocityChart').getContext('2d');
        const velocityChart = new Chart(velocityCtx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Motor 0 Velocity (t/s)',
                        data: velocityDataMotor0,
                        borderColor: 'rgb(88, 166, 255)',  // Blue
                        backgroundColor: 'rgba(88, 166, 255, 0.1)',
                        tension: 0.1,
                        borderWidth: 2
                    },
                    {
                        label: 'Motor 1 Velocity (t/s)',
                        data: velocityDataMotor1,
                        borderColor: 'rgb(188, 140, 255)',  // Purple
                        backgroundColor: 'rgba(188, 140, 255, 0.1)',
                        tension: 0.1,
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Velocity (turns/sec)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    }
                },
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });

        // ========== PRESET MANAGER CLASS ==========
        class PresetManager {
            constructor() {
                this.storageKey = 'odrive_position_presets';
                this.data = this.loadFromStorage();
                this.maxPresets = 10;
                this.availableColors = ['#0d6efd', '#198754', '#dc3545', '#ffc107',
                                        '#0dcaf0', '#6f42c1', '#fd7e14', '#20c997'];
            }

            loadFromStorage() {
                const stored = localStorage.getItem(this.storageKey);
                if (stored) {
                    try {
                        return JSON.parse(stored);
                    } catch (e) {
                        console.error('Failed to parse presets:', e);
                    }
                }
                return { version: 1, presets: [], waypoints: [] };
            }

            saveToStorage() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.data));
            }

            addPreset(name, position, hotkey = null) {
                if (this.data.presets.length >= this.maxPresets) {
                    throw new Error('Maximum 10 presets allowed');
                }

                const preset = {
                    id: `preset_${Date.now()}`,
                    name: name,
                    position: position,
                    color: this.getNextColor(),
                    hotkey: hotkey || this.getNextAvailableHotkey(),
                    created: Date.now(),
                    lastUsed: Date.now()
                };

                this.data.presets.push(preset);
                this.saveToStorage();
                return preset;
            }

            removePreset(id) {
                this.data.presets = this.data.presets.filter(p => p.id !== id);
                this.saveToStorage();
            }

            updatePreset(id, updates) {
                const preset = this.data.presets.find(p => p.id === id);
                if (preset) {
                    Object.assign(preset, updates);
                    this.saveToStorage();
                }
            }

            goToPreset(id) {
                const preset = this.data.presets.find(p => p.id === id);
                if (preset) {
                    preset.lastUsed = Date.now();
                    this.saveToStorage();
                    return preset.position;
                }
                return null;
            }

            getNextAvailableHotkey() {
                const usedKeys = new Set(this.data.presets.map(p => p.hotkey));
                for (let i = 1; i <= 9; i++) {
                    if (!usedKeys.has(String(i))) return String(i);
                }
                if (!usedKeys.has('0')) return '0';
                return null;  // All hotkeys used
            }

            getNextColor() {
                const usedColors = new Set(this.data.presets.map(p => p.color));
                for (const color of this.availableColors) {
                    if (!usedColors.has(color)) return color;
                }
                return this.availableColors[0];  // Fallback
            }

            // Waypoint methods
            addWaypoint(name, positions, pauseDuration = 1000, loop = false) {
                const waypoint = {
                    id: `waypoint_${Date.now()}`,
                    name: name,
                    positions: positions,
                    pauseDuration: pauseDuration,
                    loop: loop,
                    created: Date.now()
                };
                this.data.waypoints.push(waypoint);
                this.saveToStorage();
                return waypoint;
            }

            removeWaypoint(id) {
                this.data.waypoints = this.data.waypoints.filter(w => w.id !== id);
                this.saveToStorage();
            }
        }

        // ========== WAYPOINT EXECUTOR CLASS ==========
        class WaypointExecutor {
            constructor(socketConnection, presetManager) {
                this.socket = socketConnection;
                this.presetManager = presetManager;
                this.isExecuting = false;
                this.currentWaypointId = null;
                this.currentStep = 0;
                this.loopCount = 0;
            }

            async executeWaypoint(waypointId) {
                if (this.isExecuting) {
                    throw new Error('Waypoint execution already in progress');
                }

                const waypoint = this.presetManager.data.waypoints.find(w => w.id === waypointId);
                if (!waypoint) {
                    throw new Error('Waypoint not found');
                }

                this.isExecuting = true;
                this.currentWaypointId = waypointId;
                this.currentStep = 0;

                // Disable execute button, enable stop button
                document.getElementById('executeWaypointBtn').disabled = true;
                document.getElementById('stopWaypointBtn').disabled = false;

                do {
                    for (let i = 0; i < waypoint.positions.length; i++) {
                        if (!this.isExecuting) break;  // Stopped externally

                        this.currentStep = i;
                        const scaledPosition = waypoint.positions[i] * positionScaleFactor;
                        this.socket.emit('set_position', { position: scaledPosition });

                        addLog(`Waypoint step ${i + 1}/${waypoint.positions.length}: Moving to ${waypoint.positions[i].toFixed(3)} turns`, 'info');

                        if (i < waypoint.positions.length - 1) {
                            await this.sleep(waypoint.pauseDuration);
                        }
                    }
                    this.loopCount++;
                } while (waypoint.loop && this.isExecuting);

                this.stop();
                addLog(`Waypoint "${waypoint.name}" completed`, 'success');
            }

            stop() {
                this.isExecuting = false;
                this.currentWaypointId = null;
                this.currentStep = 0;
                this.loopCount = 0;

                // Re-enable execute button, disable stop button
                document.getElementById('executeWaypointBtn').disabled = false;
                document.getElementById('stopWaypointBtn').disabled = true;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize preset manager and waypoint executor
        const presetManager = new PresetManager();
        const waypointExecutor = new WaypointExecutor(socket, presetManager);

        // ========== AUTO-CALIBRATION EXECUTOR ==========
        class CalibrationExecutor {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isCalibrating = false;
                this.currentStep = 0;
                this.steps = [
                    { name: 'Record Starting Position', progress: 10 },
                    { name: 'Rotate 1 Turn (Raw Command)', progress: 35 },
                    { name: 'Measure Actual Movement', progress: 60 },
                    { name: 'Return to Start', progress: 80 },
                    { name: 'Verify Return Position', progress: 95 },
                    { name: 'Calculate Results', progress: 100 }
                ];
                this.calibrationData = {
                    startPosition: 0,
                    afterRotationPosition: 0,
                    endPosition: 0,
                    commandedRotation: 1.0,
                    actualRotation: 0,
                    currentScaleFactor: positionScaleFactor,
                    recommendedScaleFactor: 0,
                    error: 0,
                    errorPercentage: 0
                };
            }

            async startCalibration() {
                if (this.isCalibrating) {
                    throw new Error('Calibration already in progress');
                }

                this.isCalibrating = true;
                this.currentStep = 0;

                const progressDiv = document.getElementById('calibrationProgress');
                const startBtn = document.getElementById('startCalibrationBtn');

                progressDiv.style.display = 'block';
                startBtn.disabled = true;

                try {
                    // IMPORTANT: Calibration uses RAW position commands (scale factor = 1.0)
                    // to measure the true motor response and calculate the correct scale factor

                    // Step 1: Record starting position (don't move)
                    await this.executeStep(0, async () => {
                        // Get current position first
                        const currentPos = parseFloat(document.getElementById('currentPosition').textContent);
                        this.calibrationData.startPosition = currentPos;
                        await this.wait(500); // Brief pause
                    });

                    // Step 2: Rotate exactly 1 turn using RAW command (no scale factor)
                    await this.executeStep(1, async () => {
                        const targetPosition = this.calibrationData.startPosition + this.calibrationData.commandedRotation;
                        // Send RAW position (scale = 1.0, ignore user's scale factor)
                        this.socket.emit('set_position', { position: targetPosition });
                        await this.wait(3000); // Wait 3 seconds for full rotation
                    });

                    // Step 3: Wait for settle and record
                    await this.executeStep(2, async () => {
                        await this.wait(1000);
                        // Record position after rotation
                        this.calibrationData.afterRotationPosition = parseFloat(document.getElementById('currentPosition').textContent);
                    });

                    // Step 4: Return to starting position using RAW command
                    await this.executeStep(3, async () => {
                        // Send RAW position (scale = 1.0, ignore user's scale factor)
                        this.socket.emit('set_position', { position: this.calibrationData.startPosition });
                        await this.wait(3000);
                    });

                    // Step 5: Wait for settle and record
                    await this.executeStep(4, async () => {
                        await this.wait(1000);
                        this.calibrationData.endPosition = parseFloat(document.getElementById('currentPosition').textContent);
                    });

                    // Step 6: Calculate results
                    await this.executeStep(5, async () => {
                        this.calculateResults();
                    });

                    // Show results modal
                    this.displayResults();

                } catch (error) {
                    addLog(`Calibration error: ${error.message}`, 'danger');
                    this.updateStatus(`Error: ${error.message}`, 100);
                } finally {
                    this.isCalibrating = false;
                    startBtn.disabled = false;

                    // Hide progress after 2 seconds
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 2000);
                }
            }

            async executeStep(stepIndex, action) {
                this.currentStep = stepIndex;
                const step = this.steps[stepIndex];

                this.updateStatus(step.name, step.progress);
                await action();
            }

            updateStatus(message, progress) {
                const statusEl = document.getElementById('calibrationStatus');
                const progressBar = document.getElementById('calibrationProgressBar');

                if (statusEl) statusEl.textContent = message;
                if (progressBar) progressBar.style.width = `${progress}%`;
            }

            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            calculateResults() {
                const { startPosition, afterRotationPosition, endPosition, commandedRotation } = this.calibrationData;

                // Calculate actual rotation from raw command (encoder feedback)
                const actualRotation = afterRotationPosition - startPosition;
                this.calibrationData.actualRotation = actualRotation;

                // Calculate position error
                this.calibrationData.error = commandedRotation - actualRotation;
                this.calibrationData.errorPercentage = (this.calibrationData.error / commandedRotation) * 100;

                // Calculate recommended scale factor from raw measurements
                // Scale factor compensates for motor response to raw commands
                // If motor moves MORE than commanded â†’ need SMALLER scale factor
                // If motor moves LESS than commanded â†’ need LARGER scale factor
                // Formula: scaleFactor = commanded / actual
                if (actualRotation !== 0 && Math.abs(actualRotation) > 0.01) {
                    this.calibrationData.recommendedScaleFactor = commandedRotation / actualRotation;
                } else {
                    this.calibrationData.recommendedScaleFactor = 1.0;
                    addLog('Warning: Actual rotation too small for accurate calibration', 'warning');
                }

                // Check return accuracy
                const returnError = Math.abs(endPosition - startPosition);
                if (returnError > 0.05) {
                    addLog(`Warning: Motor didn't return to start accurately (error: ${returnError.toFixed(3)} turns)`, 'warning');
                }
            }

            displayResults() {
                const { startPosition, afterRotationPosition, endPosition, commandedRotation,
                        actualRotation, currentScaleFactor, recommendedScaleFactor,
                        error, errorPercentage } = this.calibrationData;

                const tolerance = 0.01; // 1% tolerance
                const isAccurate = Math.abs(error) <= tolerance;

                let resultClass = isAccurate ? 'success' : 'warning';
                let resultIcon = isAccurate ? 'check-circle-fill' : 'exclamation-triangle-fill';
                let resultMessage = isAccurate
                    ? 'Calibration complete! Motor response is accurate (within 1% tolerance).'
                    : 'Calibration detected position error. Apply the recommended scale factor to improve accuracy.';

                const html = `
                    <div class="alert alert-${resultClass}">
                        <i class="bi bi-${resultIcon}"></i> <strong>${resultMessage}</strong>
                    </div>

                    <h6>Calibration Data:</h6>
                    <table class="table table-sm">
                        <tr>
                            <td><strong>Start Position:</strong></td>
                            <td>${startPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>After 1 Turn Command:</strong></td>
                            <td>${afterRotationPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Return to Zero:</strong></td>
                            <td>${endPosition.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Commanded Rotation:</strong></td>
                            <td>${commandedRotation.toFixed(4)} turns</td>
                        </tr>
                        <tr>
                            <td><strong>Actual Rotation:</strong></td>
                            <td>${actualRotation.toFixed(4)} turns</td>
                        </tr>
                        <tr class="${Math.abs(error) > tolerance ? 'table-warning' : ''}">
                            <td><strong>Position Error:</strong></td>
                            <td>${error.toFixed(4)} turns (${errorPercentage.toFixed(2)}%)</td>
                        </tr>
                    </table>

                    <h6>Scale Factor:</h6>
                    <table class="table table-sm">
                        <tr>
                            <td><strong>Current Scale Factor:</strong></td>
                            <td>${currentScaleFactor.toFixed(2)}x</td>
                        </tr>
                        <tr class="${!isAccurate ? 'table-info' : ''}">
                            <td><strong>Recommended Scale Factor:</strong></td>
                            <td>${recommendedScaleFactor.toFixed(2)}x</td>
                        </tr>
                    </table>

                    ${!isAccurate ? `
                        <div class="alert alert-info mt-3">
                            <strong>Recommendation:</strong> Click "Apply Recommended Scale Factor" to update the scale factor to ${recommendedScaleFactor.toFixed(2)}x.
                            This should improve position accuracy.
                        </div>
                    ` : `
                        <div class="alert alert-success mt-3">
                            <strong>No action needed.</strong> Your position tracking is already accurate within ${(tolerance * 100).toFixed(1)}% tolerance.
                        </div>
                    `}
                `;

                document.getElementById('calibrationResultsContent').innerHTML = html;

                // Show/hide apply button based on accuracy
                const applyBtn = document.getElementById('applyCalibrationBtn');
                if (applyBtn) {
                    applyBtn.style.display = isAccurate ? 'none' : 'inline-block';
                }

                const modal = new bootstrap.Modal(document.getElementById('calibrationResultsModal'));
                modal.show();

                addLog('Calibration complete', 'success');
            }

            getRecommendedScaleFactor() {
                return this.calibrationData.recommendedScaleFactor;
            }
        }

        // Initialize calibration executor
        const calibrationExecutor = new CalibrationExecutor(socket);

        // ========== SESSION RECORDER & PLAYBACK ==========
        class SessionRecorder {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isRecording = false;
                this.recordingData = [];
                this.startTime = 0;
                this.recordingTimer = null;
                this.sampleRate = 10; // Hz (every 100ms)
            }

            startRecording(sessionName) {
                if (this.isRecording) {
                    throw new Error('Recording already in progress');
                }

                this.isRecording = true;
                this.recordingData = [];
                this.startTime = Date.now();
                this.sessionName = sessionName || `Session_${new Date().toISOString().replace(/[:.]/g, '-')}`;

                // Start recording timer
                this.recordingTimer = setInterval(() => {
                    this.recordDataPoint();
                }, 1000 / this.sampleRate);

                addLog(`Recording started: ${this.sessionName}`, 'info');
            }

            recordDataPoint() {
                if (!this.isRecording) return;

                const currentTime = (Date.now() - this.startTime) / 1000; // seconds
                const position = parseFloat(document.getElementById('currentPosition').textContent) || 0;
                const velocity = parseFloat(document.getElementById('currentVelocity').textContent) || 0;

                this.recordingData.push({
                    timestamp: currentTime,
                    position: position,
                    velocity: velocity
                });
            }

            stopRecording() {
                if (!this.isRecording) return null;

                this.isRecording = false;
                clearInterval(this.recordingTimer);

                const duration = (Date.now() - this.startTime) / 1000;

                const sessionData = {
                    session_metadata: {
                        name: this.sessionName,
                        start_time: new Date(this.startTime).toISOString(),
                        duration_seconds: duration,
                        sample_rate_hz: this.sampleRate,
                        data_points_count: this.recordingData.length
                    },
                    data_points: this.recordingData
                };

                addLog(`Recording stopped: ${duration.toFixed(1)}s, ${this.recordingData.length} points`, 'success');

                return sessionData;
            }

            getDuration() {
                if (!this.isRecording) return 0;
                return (Date.now() - this.startTime) / 1000;
            }
        }

        class SessionPlayback {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.isPlaying = false;
                this.isPaused = false;
                this.sessionData = null;
                this.currentIndex = 0;
                this.playbackSpeed = 1.0;
                this.playbackTimer = null;
                this.startTime = 0;
                this.pauseTime = 0;
                this.pausedDuration = 0;
            }

            loadSession(sessionData) {
                if (this.isPlaying) {
                    throw new Error('Cannot load session while playing');
                }

                this.sessionData = sessionData;
                this.currentIndex = 0;
                addLog(`Session loaded: ${sessionData.session_metadata.name}`, 'info');
            }

            play() {
                if (!this.sessionData) {
                    throw new Error('No session loaded');
                }

                if (this.isPaused) {
                    // Resume from pause
                    this.isPaused = false;
                    this.pausedDuration += Date.now() - this.pauseTime;
                    this.scheduleNextPoint();
                    addLog('Playback resumed', 'info');
                    return;
                }

                if (this.isPlaying) {
                    addLog('Already playing', 'warning');
                    return;
                }

                this.isPlaying = true;
                this.currentIndex = 0;
                this.startTime = Date.now();
                this.pausedDuration = 0;

                addLog(`Playback started: ${this.sessionData.session_metadata.name}`, 'info');
                this.scheduleNextPoint();
            }

            pause() {
                if (!this.isPlaying || this.isPaused) return;

                this.isPaused = true;
                this.pauseTime = Date.now();
                clearTimeout(this.playbackTimer);
                addLog('Playback paused', 'info');
            }

            stop() {
                if (!this.isPlaying) return;

                this.isPlaying = false;
                this.isPaused = false;
                this.currentIndex = 0;
                clearTimeout(this.playbackTimer);

                // Stop motor
                this.socket.emit('stop');
                addLog('Playback stopped', 'info');
            }

            scheduleNextPoint() {
                if (!this.isPlaying || this.isPaused) return;

                if (this.currentIndex >= this.sessionData.data_points.length) {
                    this.stop();
                    addLog('Playback complete', 'success');
                    return;
                }

                const dataPoint = this.sessionData.data_points[this.currentIndex];
                const elapsedTime = (Date.now() - this.startTime - this.pausedDuration) / 1000;
                const targetTime = dataPoint.timestamp / this.playbackSpeed;

                if (elapsedTime >= targetTime) {
                    // Execute this point
                    const scaledPosition = dataPoint.position * positionScaleFactor;
                    this.socket.emit('set_position', { position: scaledPosition });

                    this.currentIndex++;

                    // Update progress UI
                    const progress = (this.currentIndex / this.sessionData.data_points.length) * 100;
                    updatePlaybackProgress(progress, elapsedTime * this.playbackSpeed);

                    // Schedule next point immediately
                    this.playbackTimer = setTimeout(() => this.scheduleNextPoint(), 0);
                } else {
                    // Wait until target time
                    const waitTime = (targetTime - elapsedTime) * 1000;
                    this.playbackTimer = setTimeout(() => this.scheduleNextPoint(), waitTime);
                }
            }

            setSpeed(speed) {
                this.playbackSpeed = Math.max(0.1, Math.min(3.0, speed));

                // If currently playing, restart timing from current point
                if (this.isPlaying && !this.isPaused) {
                    this.startTime = Date.now();
                    this.pausedDuration = 0;
                    // Adjust to current timestamp
                    if (this.currentIndex > 0) {
                        const currentDataPoint = this.sessionData.data_points[this.currentIndex - 1];
                        this.startTime -= (currentDataPoint.timestamp / this.playbackSpeed) * 1000;
                    }
                }
            }

            getProgress() {
                if (!this.sessionData) return 0;
                return (this.currentIndex / this.sessionData.data_points.length) * 100;
            }

            getCurrentTime() {
                if (!this.sessionData || this.currentIndex === 0) return 0;
                const dataPoint = this.sessionData.data_points[this.currentIndex - 1];
                return dataPoint.timestamp;
            }

            getDuration() {
                if (!this.sessionData) return 0;
                return this.sessionData.session_metadata.duration_seconds;
            }
        }

        // Initialize session recorder and playback
        const sessionRecorder = new SessionRecorder(socket);
        const sessionPlayback = new SessionPlayback(socket);

        // ========== GAMEPAD CONTROLLER ==========
        class GamepadController {
            constructor(socketConnection) {
                this.socket = socketConnection;
                this.enabled = false;
                this.gamepad = null;
                this.pollInterval = null;
                this.deadzone = 0.15;
                this.currentVelocity = 0;
                this.maxVelocity = 10.0;
                this.lastButtonStates = {};

                // Button mappings (standard gamepad layout)
                this.buttonMap = {
                    0: 'A',      // Stop
                    1: 'B',      // Zero position
                    2: 'X',      // Play sequence
                    3: 'Y',      // Record
                    9: 'Start',  // Emergency stop
                    12: 'Up',    // D-pad up
                    13: 'Down',  // D-pad down
                    14: 'Left',  // D-pad left
                    15: 'Right'  // D-pad right
                };

                this.init();
            }

            init() {
                // Listen for gamepad connection events
                window.addEventListener('gamepadconnected', (e) => this.onGamepadConnected(e));
                window.addEventListener('gamepaddisconnected', (e) => this.onGamepadDisconnected(e));

                // Check for already connected gamepads
                this.checkForGamepads();

                // Setup enable checkbox
                const enableCheckbox = document.getElementById('gamepadEnabled');
                if (enableCheckbox) {
                    enableCheckbox.addEventListener('change', (e) => {
                        this.setEnabled(e.target.checked);
                    });
                }
            }

            checkForGamepads() {
                const gamepads = navigator.getGamepads();
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        this.onGamepadConnected({ gamepad: gamepads[i] });
                        break;
                    }
                }
            }

            onGamepadConnected(event) {
                this.gamepad = event.gamepad;
                this.updateStatus(`${this.gamepad.id} connected`, 'success');
                document.getElementById('gamepadControls').style.display = 'block';
                addLog(`Gamepad connected: ${this.gamepad.id}`, 'info');
            }

            onGamepadDisconnected(event) {
                this.updateStatus('No gamepad detected', 'warning');
                document.getElementById('gamepadControls').style.display = 'none';
                this.stopPolling();
                this.gamepad = null;
                addLog('Gamepad disconnected', 'warning');
            }

            updateStatus(text, type = 'info') {
                const statusDiv = document.getElementById('gamepadStatus');
                const statusText = document.getElementById('gamepadStatusText');

                if (statusText) statusText.textContent = text;

                if (statusDiv) {
                    statusDiv.className = 'alert alert-sm mb-2';
                    if (type === 'success') statusDiv.classList.add('alert-success');
                    else if (type === 'warning') statusDiv.classList.add('alert-warning');
                    else statusDiv.classList.add('alert-info');
                }
            }

            setEnabled(enabled) {
                this.enabled = enabled;

                if (enabled && this.gamepad) {
                    this.startPolling();
                    addLog('Gamepad control enabled', 'success');
                } else {
                    this.stopPolling();
                    addLog('Gamepad control disabled', 'info');
                }
            }

            startPolling() {
                if (this.pollInterval) return;

                this.pollInterval = setInterval(() => {
                    this.poll();
                }, 50); // 20Hz polling
            }

            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                    // Stop motor when disabling
                    this.socket.emit('set_velocity', { velocity: 0 });
                }
            }

            poll() {
                if (!this.enabled || !this.gamepad) return;

                // Get fresh gamepad state
                const gamepads = navigator.getGamepads();
                this.gamepad = gamepads[this.gamepad.index];

                if (!this.gamepad) return;

                // Process analog sticks
                this.processAnalogInputs();

                // Process buttons
                this.processButtons();
            }

            processAnalogInputs() {
                // Left stick Y axis (index 1) - velocity control
                const leftY = this.gamepad.axes[1] || 0;

                // Apply deadzone
                const velocity = Math.abs(leftY) > this.deadzone
                    ? -leftY * this.maxVelocity  // Invert Y axis (up = positive)
                    : 0;

                // Only send if velocity changed significantly
                if (Math.abs(velocity - this.currentVelocity) > 0.1) {
                    this.currentVelocity = velocity;
                    this.socket.emit('set_velocity', { velocity: velocity });
                }

                // Triggers - fine velocity adjust
                const leftTrigger = this.gamepad.buttons[6]?.value || 0;
                const rightTrigger = this.gamepad.buttons[7]?.value || 0;

                if (leftTrigger > 0.1 || rightTrigger > 0.1) {
                    const fineVelocity = (rightTrigger - leftTrigger) * 2.0; // Max Â±2.0
                    this.socket.emit('set_velocity', { velocity: fineVelocity });
                }
            }

            processButtons() {
                this.gamepad.buttons.forEach((button, index) => {
                    const pressed = button.pressed;
                    const wasPressed = this.lastButtonStates[index] || false;

                    // Detect button press (not held)
                    if (pressed && !wasPressed) {
                        this.handleButtonPress(index);
                    }

                    this.lastButtonStates[index] = pressed;
                });
            }

            handleButtonPress(buttonIndex) {
                const buttonName = this.buttonMap[buttonIndex];

                switch (buttonIndex) {
                    case 0: // A - Stop
                        this.socket.emit('stop');
                        addLog('Gamepad: Stop', 'info');
                        break;

                    case 1: // B - Zero position
                        this.socket.emit('set_position', { position: 0 });
                        addLog('Gamepad: Go to zero', 'info');
                        break;

                    case 2: // X - Play sequence
                        if (document.getElementById('sequenceSelect').value) {
                            playSequence();
                        }
                        break;

                    case 3: // Y - Record toggle
                        if (sessionRecorder.isRecording) {
                            stopRecording();
                        } else {
                            startRecording();
                        }
                        break;

                    case 9: // Start - Emergency stop
                        emergencyStop();
                        break;

                    case 12: // D-pad Up - Next preset
                    case 13: // D-pad Down - Previous preset
                    case 14: // D-pad Left
                    case 15: // D-pad Right
                        this.handleDPad(buttonIndex);
                        break;
                }
            }

            handleDPad(buttonIndex) {
                const presets = presetManager.data.presets;
                if (presets.length === 0) return;

                let currentIndex = -1;
                const currentPos = parseFloat(document.getElementById('currentPosition').textContent);

                // Find closest preset
                presets.forEach((preset, index) => {
                    if (Math.abs(preset.position - currentPos) < 0.1) {
                        currentIndex = index;
                    }
                });

                let newIndex = currentIndex;

                if (buttonIndex === 12) { // Up
                    newIndex = (currentIndex + 1) % presets.length;
                } else if (buttonIndex === 13) { // Down
                    newIndex = currentIndex > 0 ? currentIndex - 1 : presets.length - 1;
                }

                if (newIndex >= 0 && newIndex < presets.length) {
                    goToPreset(presets[newIndex].id);
                }
            }
        }

        // Initialize gamepad controller
        const gamepadController = new GamepadController(socket);

        // ========== KEYBOARD SHORTCUTS MANAGER ==========
        class KeyboardShortcutManager {
            constructor(config) {
                this.config = config;
                this.enabled = this.loadEnabledState();
                this.actionMap = this.buildActionMap();
                this.pressedKeys = new Set();

                this.init();
            }

            loadEnabledState() {
                const stored = localStorage.getItem('keyboard_shortcuts_enabled');
                return stored !== null ? JSON.parse(stored) : true;
            }

            saveEnabledState() {
                localStorage.setItem('keyboard_shortcuts_enabled', JSON.stringify(this.enabled));
            }

            buildActionMap() {
                return {
                    emergencyStop: () => emergencyStop(),
                    increaseVelocity: (params) => {
                        adjustVelocity(params.delta);
                        applyVelocity();
                    },
                    decreaseVelocity: (params) => {
                        adjustVelocity(-params.delta);
                        applyVelocity();
                    },
                    goToPreset: (params) => {
                        const preset = presetManager.data.presets.find(p => p.hotkey === params.hotkey);
                        if (preset) {
                            goToPreset(preset.id);
                        }
                    },
                    switchMode: (params) => {
                        const modeRadio = document.getElementById(params.mode + 'Mode');
                        if (modeRadio) {
                            modeRadio.checked = true;
                            switchControlMode(params.mode);
                        }
                    },
                    saveCurrentAsPreset: () => saveCurrentAsPreset(),
                    goToHome: () => {
                        socket.emit('set_position', { position: 0 });
                        addLog('Going to home position (0.0)', 'info');
                    },
                    toggleLogPanel: () => toggleLogPanel(),
                    showShortcutHelp: () => this.showHelpModal()
                };
            }

            init() {
                document.addEventListener('keydown', this.handleKeyDown.bind(this), true);
                document.addEventListener('keyup', this.handleKeyUp.bind(this), true);
                addLog('Keyboard shortcuts enabled. Press ? for help.', 'info');
            }

            handleKeyDown(event) {
                if (this.isInputElement(event.target)) {
                    return;
                }

                if (!this.enabled) {
                    return;
                }

                const keyCode = this.getKeyCode(event);
                const binding = this.config.bindings[keyCode];

                if (!binding) {
                    return;
                }

                if (binding.requireCtrl && !event.ctrlKey) return;
                if (binding.requireShift && !event.shiftKey) return;
                if (binding.requireAlt && !event.altKey) return;

                if (binding.preventDefault) {
                    event.preventDefault();
                    event.stopPropagation();
                }

                if (!binding.repeat && this.pressedKeys.has(keyCode)) {
                    return;
                }

                this.pressedKeys.add(keyCode);

                try {
                    const action = this.actionMap[binding.action];
                    if (action) {
                        action(binding.params || {});
                    } else {
                        console.warn(`Unknown action: ${binding.action}`);
                    }
                } catch (error) {
                    console.error(`Error executing shortcut ${keyCode}:`, error);
                    addLog(`Shortcut error: ${error.message}`, 'danger');
                }
            }

            handleKeyUp(event) {
                const keyCode = this.getKeyCode(event);
                this.pressedKeys.delete(keyCode);
            }

            getKeyCode(event) {
                if (event.key === 'ArrowUp') return 'arrowUp';
                if (event.key === 'ArrowDown') return 'arrowDown';
                if (event.key === 'ArrowLeft') return 'arrowLeft';
                if (event.key === 'ArrowRight') return 'arrowRight';
                if (event.key === ' ' || event.code === 'Space') return 'space';
                if (event.key === '?' || (event.key === '/' && event.shiftKey)) return 'keySlash';

                if (/^Digit[0-9]$/.test(event.code)) return event.code.toLowerCase();
                if (/^Key[A-Z]$/.test(event.code)) return event.code.toLowerCase();

                return event.key.toLowerCase();
            }

            isInputElement(element) {
                const tagName = element.tagName.toLowerCase();
                return (
                    tagName === 'input' ||
                    tagName === 'textarea' ||
                    tagName === 'select' ||
                    element.isContentEditable
                );
            }

            showHelpModal() {
                this.renderHelpContent();
                const modal = new bootstrap.Modal(document.getElementById('shortcutHelpModal'));
                modal.show();
            }

            renderHelpContent() {
                const container = document.getElementById('shortcutHelpContent');

                const categories = {
                    safety: 'Safety Controls',
                    velocity: 'Velocity Control',
                    presets: 'Position Presets',
                    modes: 'Control Modes',
                    navigation: 'Navigation',
                    help: 'Help'
                };

                let html = '';

                for (const [categoryKey, categoryName] of Object.entries(categories)) {
                    const shortcuts = Object.entries(this.config.bindings)
                        .filter(([_, binding]) => binding.category === categoryKey);

                    if (shortcuts.length === 0) continue;

                    html += `<h6 class="mt-3">${categoryName}</h6>`;
                    html += '<table class="table table-sm table-hover">';
                    html += '<thead><tr><th>Key</th><th>Action</th></tr></thead>';
                    html += '<tbody>';

                    for (const [keyCode, binding] of shortcuts) {
                        const keyDisplay = this.formatKeyDisplay(keyCode, binding);
                        html += `<tr><td><kbd>${keyDisplay}</kbd></td><td>${binding.description}</td></tr>`;
                    }

                    html += '</tbody></table>';
                }

                container.innerHTML = html;
            }

            formatKeyDisplay(keyCode, binding) {
                let display = keyCode
                    .replace('arrow', '')
                    .replace('digit', '')
                    .replace('key', '')
                    .toUpperCase();

                if (keyCode === 'arrowUp') display = 'â†‘';
                if (keyCode === 'arrowDown') display = 'â†“';
                if (keyCode === 'arrowLeft') display = 'â†';
                if (keyCode === 'arrowRight') display = 'â†’';
                if (keyCode === 'space') display = 'SPACE';
                if (keyCode === 'keySlash') display = '?';

                if (binding.requireCtrl) display = 'Ctrl + ' + display;
                if (binding.requireShift) display = 'Shift + ' + display;
                if (binding.requireAlt) display = 'Alt + ' + display;

                return display;
            }

            toggle() {
                this.enabled = !this.enabled;
                this.saveEnabledState();
                addLog(`Keyboard shortcuts ${this.enabled ? 'enabled' : 'disabled'}`, 'info');
            }

            isEnabled() {
                return this.enabled;
            }
        }

        // Keyboard shortcut configuration
        const keyboardShortcuts = {
            version: 1,
            enabled: true,
            bindings: {
                space: {
                    action: 'emergencyStop',
                    description: 'Emergency Stop',
                    category: 'safety',
                    preventDefault: true
                },
                arrowUp: {
                    action: 'increaseVelocity',
                    params: { delta: 0.5 },
                    description: 'Increase velocity by 0.5 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowDown: {
                    action: 'decreaseVelocity',
                    params: { delta: 0.5 },
                    description: 'Decrease velocity by 0.5 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowLeft: {
                    action: 'decreaseVelocity',
                    params: { delta: 0.1 },
                    description: 'Fine decrease velocity by 0.1 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                arrowRight: {
                    action: 'increaseVelocity',
                    params: { delta: 0.1 },
                    description: 'Fine increase velocity by 0.1 turns/sec',
                    category: 'velocity',
                    repeat: true
                },
                digit1: { action: 'goToPreset', params: { hotkey: '1' }, description: 'Go to preset 1', category: 'presets' },
                digit2: { action: 'goToPreset', params: { hotkey: '2' }, description: 'Go to preset 2', category: 'presets' },
                digit3: { action: 'goToPreset', params: { hotkey: '3' }, description: 'Go to preset 3', category: 'presets' },
                digit4: { action: 'goToPreset', params: { hotkey: '4' }, description: 'Go to preset 4', category: 'presets' },
                digit5: { action: 'goToPreset', params: { hotkey: '5' }, description: 'Go to preset 5', category: 'presets' },
                digit6: { action: 'goToPreset', params: { hotkey: '6' }, description: 'Go to preset 6', category: 'presets' },
                digit7: { action: 'goToPreset', params: { hotkey: '7' }, description: 'Go to preset 7', category: 'presets' },
                digit8: { action: 'goToPreset', params: { hotkey: '8' }, description: 'Go to preset 8', category: 'presets' },
                digit9: { action: 'goToPreset', params: { hotkey: '9' }, description: 'Go to preset 9', category: 'presets' },
                digit0: { action: 'goToPreset', params: { hotkey: '0' }, description: 'Go to preset 0', category: 'presets' },
                keyv: { action: 'switchMode', params: { mode: 'velocity' }, description: 'Switch to Velocity mode', category: 'modes' },
                keyj: { action: 'switchMode', params: { mode: 'joystick' }, description: 'Switch to Joystick mode', category: 'modes' },
                keyr: { action: 'switchMode', params: { mode: 'rotation' }, description: 'Switch to Rotation Knob mode', category: 'modes' },
                keyi: { action: 'switchMode', params: { mode: 'ik' }, description: 'Switch to IK Control mode', category: 'modes' },
                keys: { action: 'saveCurrentAsPreset', description: 'Save current position as preset', category: 'presets', requireCtrl: false },
                keyh: { action: 'goToHome', description: 'Go to home position (0.0)', category: 'navigation' },
                keyl: { action: 'toggleLogPanel', description: 'Toggle System Log', category: 'navigation', requireCtrl: true },
                keySlash: { action: 'showShortcutHelp', description: 'Show keyboard shortcuts', category: 'help', requireShift: true }
            }
        };

        // Initialize keyboard shortcuts
        const keyboardShortcutManager = new KeyboardShortcutManager(keyboardShortcuts);

        // Battery alert audio system
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let lastAlertSound = 0;
        const ALERT_SOUND_INTERVAL = 5000;  // 5 seconds between beeps

        // Alert silence state (persisted in localStorage)
        let alertsSilenced = localStorage.getItem('alertsSilenced') === 'true';

        function playAlertBeep(frequency, duration, type = 'warning') {
            // Don't play if alerts are silenced
            if (alertsSilenced) return;

            const now = Date.now();

            // Rate limiting (except critical alerts)
            if (type !== 'critical' && now - lastAlertSound < ALERT_SOUND_INTERVAL) {
                return;
            }
            lastAlertSound = now;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playBatteryAlert(level) {
            if (level === 'critical') {
                // Urgent triple beep
                playAlertBeep(880, 0.15, 'critical');
                setTimeout(() => playAlertBeep(880, 0.15, 'critical'), 200);
                setTimeout(() => playAlertBeep(880, 0.15, 'critical'), 400);
            } else if (level === 'urgent') {
                // Double beep
                playAlertBeep(660, 0.2, 'urgent');
                setTimeout(() => playAlertBeep(660, 0.2, 'urgent'), 300);
            } else if (level === 'warning') {
                // Single beep
                playAlertBeep(440, 0.3, 'warning');
            }
        }

        // Browser notification system
        let notificationPermission = Notification.permission;

        function requestNotificationPermission() {
            if ('Notification' in window && notificationPermission === 'default') {
                Notification.requestPermission().then(permission => {
                    notificationPermission = permission;
                });
            }
        }

        function showBatteryNotification(level, message, voltage) {
            // Don't show notifications if alerts are silenced
            if (alertsSilenced) return;
            if (notificationPermission !== 'granted') return;

            const title = level === 'critical' ? 'âš ï¸ BATTERY CRITICAL' :
                          level === 'urgent' ? 'âš ï¸ Battery Urgent' :
                          'âš ï¸ Battery Warning';

            const notification = new Notification(title, {
                body: message,
                requireInteraction: level === 'critical',  // Keep visible until closed
                tag: 'battery-alert',  // Replaces previous notifications
            });

            notification.onclick = () => {
                window.focus();
                notification.close();
            };
        }

        function flashCriticalAlert() {
            // Don't flash if alerts are silenced
            if (alertsSilenced) return;

            // Flash the sidebar red briefly
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.style.transition = 'background-color 0.3s';
                sidebar.style.backgroundColor = 'rgba(220, 53, 69, 0.1)';
                setTimeout(() => {
                    sidebar.style.backgroundColor = '';
                }, 1000);
            }
        }

        // Alert silence functions
        function toggleAlertSilence() {
            alertsSilenced = !alertsSilenced;
            localStorage.setItem('alertsSilenced', alertsSilenced);
            updateSilenceButton();

            if (alertsSilenced) {
                addLog('Battery alerts silenced (beeps/notifications disabled)', 'info');
            } else {
                addLog('Battery alerts enabled', 'info');
            }
        }

        function updateSilenceButton() {
            const btn = document.getElementById('silenceAlertsButton');
            if (btn) {
                if (alertsSilenced) {
                    btn.innerHTML = '<i class="bi bi-bell-slash"></i> Alerts Silenced';
                    btn.classList.remove('btn-secondary-modern');
                    btn.classList.add('btn-warning-modern');
                } else {
                    btn.innerHTML = '<i class="bi bi-bell"></i> Silence Alerts';
                    btn.classList.remove('btn-warning-modern');
                    btn.classList.add('btn-secondary-modern');
                }
            }
        }

        function showMotorShutdownBanner() {
            // Check if banner already exists
            if (document.getElementById('shutdownBanner')) return;

            const banner = document.createElement('div');
            banner.id = 'shutdownBanner';
            banner.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #dc3545;
                color: white;
                padding: 15px 30px;
                border-radius: 8px;
                font-weight: bold;
                font-size: 1.2rem;
                z-index: 9999;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            banner.textContent = 'âš ï¸ MOTORS DISABLED - BATTERY PROTECTION ACTIVE';

            document.body.appendChild(banner);

            // Auto-remove after 10 seconds (will reappear if still in shutdown)
            setTimeout(() => {
                if (document.getElementById('shutdownBanner')) {
                    banner.remove();
                }
            }, 10000);
        }

        // Request notification permission on page load
        document.addEventListener('DOMContentLoaded', () => {
            requestNotificationPermission();
            updateSilenceButton();  // Initialize silence button state
        });

        // Socket.IO event handlers
        socket.on('connect', function() {
            console.log('[DEBUG] Socket connected');
            updateConnectionStatus(true);
            addLog('Connected to server', 'success');

            // Restore saved control mode after connection (with small delay)
            setTimeout(() => {
                restoreSavedControlMode();
            }, 1000);
        });

        socket.on('disconnect', function(reason) {
            console.log('[DEBUG] Socket disconnected. Reason:', reason);
            updateConnectionStatus(false);
            addLog('Disconnected from server', 'danger');
        });

        // Health monitor tracking
        let feedbackCount = 0;
        let feedbackRateTimer = null;
        if (!feedbackRateTimer) {
            feedbackRateTimer = setInterval(() => {
                document.getElementById('healthFeedbackRate').textContent = feedbackCount + ' Hz';
                feedbackCount = 0;
            }, 1000);
        }

        socket.on('feedback', function(data) {
            console.log('[DEBUG] FEEDBACK event received:', data);

            // Multi-motor feedback handling
            if (data.joints && Array.isArray(data.joints)) {
                // Update each motor panel and chart
                data.joints.forEach((joint, motorId) => {
                    if (document.getElementById(`motor${motorId}-position`)) {
                        document.getElementById(`motor${motorId}-position`).textContent = joint.position.toFixed(3);
                        document.getElementById(`motor${motorId}-velocity`).textContent = joint.velocity.toFixed(3);
                    }

                    // Update chart data for each motor
                    updateMotorChartData(motorId, joint.position, joint.velocity);
                });

                // Force chart update after both motors processed (Motor 1 updates)
                if (data.joints.length > 1) {
                    positionChart.update();
                    velocityChart.update();
                }

                // Update sidebar with motor 0 data for backward compatibility
                if (data.joints[0]) {
                    updateSidebarInfo(data.joints[0].position, data.joints[0].velocity);
                    currentMotorPosition = data.joints[0].position;
                }

                // Update robot visualizer
                const angles = data.joints.map(j => j.position);
                robotVisualizer.updateJointAngles(angles);
            } else {
                // Legacy single-motor mode
                updateDisplay(data.position, data.velocity);
                updateSidebarInfo(data.position, data.velocity);
                currentMotorPosition = data.position;

                // Single motor mode - treat as joint 0
                if (data.position !== null && typeof data.position !== 'undefined') {
                    robotVisualizer.updateJointAngles([data.position, 0]);
                }
            }

            // Update health monitor
            feedbackCount++;
            const now = new Date();
            document.getElementById('healthLastUpdate').textContent = now.toLocaleTimeString();
            document.getElementById('healthConnection').textContent = 'Connected';
            document.getElementById('healthConnection').className = 'text-success';

            // Initialize rotation knob on first feedback (sync with motor position)
            if (!initializedRotationKnob && currentMotorPosition !== null && typeof currentMotorPosition !== 'undefined') {
                cumulativeRotation = currentMotorPosition * 360;
                rotationZeroPosition = 0;
                updateRotationKnobDisplay();
                initializedRotationKnob = true;
                // Force update displays after a brief delay to ensure elements exist
                setTimeout(() => {
                    updateRotationKnobDisplay();
                }, 100);
                addLog('Rotation knob synchronized with motor position', 'success');
            }
        });

        // Multi-motor health event handler
        socket.on('health_motor', function(data) {
            const motorId = data.motor_id;

            // Update motor state
            if (data.axis_state !== null && document.getElementById(`motor${motorId}-state`)) {
                const stateNames = {
                    0: 'UNDEFINED',
                    1: 'IDLE',
                    8: 'CLOSED_LOOP'
                };
                const stateName = stateNames[data.axis_state] || `STATE_${data.axis_state}`;
                document.getElementById(`motor${motorId}-state`).textContent = stateName;

                // Update state icon
                const stateIcon = document.getElementById(`motor${motorId}-state-icon`);
                if (stateIcon) {
                    if (data.axis_state === 8) {
                        stateIcon.textContent = 'ðŸŸ¢'; // Green for closed loop
                    } else if (data.axis_state === 1) {
                        stateIcon.textContent = 'ðŸ”´'; // Red for idle
                    } else {
                        stateIcon.textContent = 'ðŸŸ¡'; // Yellow for other
                    }
                }
            }

            // Update health metrics
            if (data.fet_temp !== null && document.getElementById(`motor${motorId}-fet-temp`)) {
                document.getElementById(`motor${motorId}-fet-temp`).textContent = `${data.fet_temp.toFixed(1)}Â°C`;
            }

            if (data.motor_temp !== null && document.getElementById(`motor${motorId}-motor-temp`)) {
                document.getElementById(`motor${motorId}-motor-temp`).textContent = `${data.motor_temp.toFixed(1)}Â°C`;
            }

            if (data.iq_measured !== null && document.getElementById(`motor${motorId}-iq`)) {
                document.getElementById(`motor${motorId}-iq`).textContent = `${data.iq_measured.toFixed(2)}A`;
            }

            // Calculate and display power (only if we have voltage and current)
            if (data.bus_voltage !== null && data.iq_measured !== null) {
                const power = Math.abs(data.bus_voltage * data.iq_measured);
                if (document.getElementById(`motor${motorId}-power`)) {
                    document.getElementById(`motor${motorId}-power`).textContent = `${power.toFixed(1)}W`;
                }
            }

            // Update shared bus display (only from motor 0)
            if (motorId === 0) {
                if (data.bus_voltage !== null && document.getElementById('shared-bus-voltage')) {
                    document.getElementById('shared-bus-voltage').textContent = data.bus_voltage.toFixed(2);
                }

                if (data.bus_current !== null && document.getElementById('shared-bus-current')) {
                    document.getElementById('shared-bus-current').textContent = data.bus_current.toFixed(2);
                }

                // Calculate total power from voltage and current
                if (data.bus_voltage !== null && data.bus_current !== null) {
                    const totalPower = Math.abs(data.bus_voltage * data.bus_current);
                    if (document.getElementById('shared-bus-power')) {
                        document.getElementById('shared-bus-power').textContent = totalPower.toFixed(1);
                    }
                }
            }
        });

        socket.on('status', function(data) {
            document.getElementById('motorState').textContent = data.state;
            addLog(`Motor state: ${data.state}`, 'info');
        });

        socket.on('error', function(data) {
            addLog(`Error: ${data.message}`, 'danger');
        });

        socket.on('command_response', function(data) {
            // Handle near-target status (from position deadband)
            if (data.response === 'NEAR_TARGET') {
                if (data.current_position !== undefined) {
                    addLog(`Already at target position (${data.current_position.toFixed(3)} turns)`, 'info');
                } else {
                    addLog(data.message || 'Already at target position', 'info');
                }
                return;
            }

            // Handle other responses
            addLog(`${data.command}: ${data.response}`, 'info');
        });

        socket.on('ik_result', function(data) {
            if (data.success) {
                document.getElementById('ikStatus').textContent = 'Success';
                document.getElementById('ikStatus').className = 'badge bg-success';
                addLog(`IK solved: error=${(data.error * 1000).toFixed(2)}mm, joints=[${data.joint_angles.map(a => a.toFixed(3)).join(', ')}]`, 'success');

                // Update visualizer with IK solution
                if (data.joint_angles.length >= 2) {
                    robotVisualizer.updateJointAngles(data.joint_angles);
                }
            } else {
                document.getElementById('ikStatus').textContent = 'Failed';
                document.getElementById('ikStatus').className = 'badge bg-danger';
                addLog(`IK failed: ${(data.error * 1000).toFixed(2)}mm from target`, 'danger');
            }
        });

        socket.on('config', function(data) {
            addLog(`Config: ${data.data}`, 'info');
        });

        socket.on('health', function(data) {
            // console.log('[DEBUG] HEALTH event received:', data);

            // Update control mode display
            const controlModeNames = {
                0: 'VOLTAGE',
                1: 'TORQUE',
                2: 'VELOCITY',
                3: 'POSITION'
            };

            const inputModeNames = {
                0: 'INACTIVE',
                1: 'PASSTHROUGH',
                2: 'VEL_RAMP',
                3: 'POS_FILTER',
                4: 'MIX_CHANNELS',
                5: 'TRAP_TRAJ',
                6: 'TORQUE_RAMP',
                7: 'MIRROR',
                8: 'TUNING'
            };

            const controlModeName = controlModeNames[data.control_mode] || `Unknown (${data.control_mode})`;
            const inputModeName = inputModeNames[data.input_mode] || `Unknown (${data.input_mode})`;

            document.getElementById('healthControlMode').textContent =
                `${controlModeName} / ${inputModeName}`;

            // Update connection status when HEALTH arrives
            const now = new Date();
            document.getElementById('healthLastUpdate').textContent = now.toLocaleTimeString();
            document.getElementById('healthConnection').textContent = 'Connected';
            document.getElementById('healthConnection').className = 'text-success';

            // Store in global variable for use elsewhere
            window.currentControlMode = data.control_mode;
            window.currentInputMode = data.input_mode;

            // Update motor state display
            if (data.axis_state !== null && data.axis_state !== undefined) {
                const stateNames = {
                    0: 'UNDEFINED',
                    1: 'IDLE',
                    2: 'STARTUP_SEQUENCE',
                    3: 'FULL_CALIBRATION',
                    4: 'MOTOR_CALIBRATION',
                    5: 'ENCODER_INDEX_SEARCH',
                    6: 'ENCODER_OFFSET_CAL',
                    7: 'CLOSED_LOOP_CONTROL',
                    8: 'CLOSED_LOOP_CONTROL',
                    9: 'LOCKIN_SPIN',
                    10: 'ENCODER_DIR_FIND',
                    11: 'HOMING',
                    12: 'ENCODER_HALL_POLARITY',
                    13: 'ENCODER_HALL_PHASE'
                };

                const stateName = stateNames[data.axis_state] || `STATE_${data.axis_state}`;
                const stateDisplay = document.getElementById('motorStateDisplay');
                const stateIcon = document.getElementById('motorStateIcon');

                if (stateDisplay) {
                    stateDisplay.textContent = stateName;
                }

                if (stateIcon) {
                    // Update icon based on state
                    if (data.axis_state === 8 || data.axis_state === 7) {
                        // Closed loop control - green
                        stateIcon.textContent = 'ðŸŸ¢';
                    } else if (data.axis_state === 4 || data.axis_state === 3) {
                        // Calibrating - yellow
                        stateIcon.textContent = 'ðŸŸ¡';
                    } else if (data.axis_state === 1) {
                        // Idle - red
                        stateIcon.textContent = 'ðŸ”´';
                    } else {
                        // Other - gray
                        stateIcon.textContent = 'âšª';
                    }
                }
            }

            // Update voltage display
            if (data.bus_voltage !== null && data.bus_voltage !== undefined) {
                const voltage = data.bus_voltage;
                document.getElementById('healthVoltage').textContent = voltage.toFixed(2);

                // Auto-unsilence alerts when battery reconnects (voltage > 20V)
                if (alertsSilenced && voltage > 20.0) {
                    alertsSilenced = false;
                    localStorage.setItem('alertsSilenced', 'false');
                    updateSilenceButton();
                    addLog('Battery reconnected - alerts re-enabled', 'info');
                }

                // Voltage status (6S LiPo: 20.4-30V protected range)
                const voltageStatus = document.getElementById('voltageStatus');
                if (voltage < 20.4) {
                    voltageStatus.innerHTML = '<span class="badge voltage-critical">CRITICAL - SHUTDOWN</span>';
                } else if (voltage < 21.0) {
                    voltageStatus.innerHTML = '<span class="badge voltage-urgent">URGENT</span>';
                } else if (voltage < 22.2) {
                    voltageStatus.innerHTML = '<span class="badge voltage-warning">Low</span>';
                } else if (voltage > 30) {
                    voltageStatus.innerHTML = '<span class="badge voltage-critical">Overvoltage</span>';
                } else if (voltage > 28) {
                    voltageStatus.innerHTML = '<span class="badge voltage-high">High</span>';
                } else {
                    voltageStatus.innerHTML = '<span class="badge voltage-normal">Normal</span>';
                }
            }

            // Update current display
            if (data.bus_current !== null && data.bus_current !== undefined) {
                const current = data.bus_current;
                document.getElementById('healthCurrent').textContent = current.toFixed(2);

                // Current status
                const currentStatus = document.getElementById('currentStatus');
                if (Math.abs(current) > 80) {
                    currentStatus.innerHTML = '<span class="badge current-critical">Very High</span>';
                } else if (Math.abs(current) > 50) {
                    currentStatus.innerHTML = '<span class="badge current-high">High</span>';
                } else {
                    currentStatus.innerHTML = '<span class="badge current-normal">Normal</span>';
                }
            }

            // Calculate and display power
            if (data.bus_voltage !== null && data.bus_current !== null) {
                const power = data.bus_voltage * data.bus_current;
                document.getElementById('healthPower').textContent = power.toFixed(1);

                // Power efficiency indicator
                const efficiency = document.getElementById('powerEfficiency');
                if (power < 10) {
                    efficiency.textContent = 'Idle';
                } else if (power < 100) {
                    efficiency.textContent = 'Low Load';
                } else if (power < 300) {
                    efficiency.textContent = 'Medium Load';
                } else {
                    efficiency.textContent = 'High Load';
                }
            }

            // Update FET temperature
            if (data.fet_temp !== null && data.fet_temp !== undefined) {
                const fetTemp = data.fet_temp;
                document.getElementById('healthFetTemp').textContent = fetTemp.toFixed(1);

                // FET temperature status
                const fetStatus = document.getElementById('fetTempStatus');
                if (fetTemp < 40) {
                    fetStatus.innerHTML = '<span class="badge temp-cool">Cool</span>';
                } else if (fetTemp < 60) {
                    fetStatus.innerHTML = '<span class="badge temp-normal">Normal</span>';
                } else if (fetTemp < 80) {
                    fetStatus.innerHTML = '<span class="badge temp-warm">Warm</span>';
                } else if (fetTemp < 100) {
                    fetStatus.innerHTML = '<span class="badge temp-hot">Hot</span>';
                } else {
                    fetStatus.innerHTML = '<span class="badge temp-critical">Critical</span>';
                }
            }

            // Update motor temperature
            if (data.motor_temp !== null && data.motor_temp !== undefined) {
                const motorTemp = data.motor_temp;
                document.getElementById('healthMotorTemp').textContent = motorTemp.toFixed(1);

                // Motor temperature status
                const motorStatus = document.getElementById('motorTempStatus');
                if (motorTemp < 40) {
                    motorStatus.innerHTML = '<span class="badge temp-cool">Cool</span>';
                } else if (motorTemp < 60) {
                    motorStatus.innerHTML = '<span class="badge temp-normal">Normal</span>';
                } else if (motorTemp < 80) {
                    motorStatus.innerHTML = '<span class="badge temp-warm">Warm</span>';
                } else if (motorTemp < 100) {
                    motorStatus.innerHTML = '<span class="badge temp-hot">Hot</span>';
                } else {
                    motorStatus.innerHTML = '<span class="badge temp-critical">Critical</span>';
                }
            }

            // Update motor current (Iq)
            if (data.iq_measured !== null && data.iq_measured !== undefined) {
                document.getElementById('healthIqMeasured').textContent = data.iq_measured.toFixed(2);
            }

            if (data.iq_setpoint !== null && data.iq_setpoint !== undefined) {
                document.getElementById('healthIqSetpoint').textContent = data.iq_setpoint.toFixed(2);
            }

            // Update sidebar Quick Info with health data
            // Update control mode in sidebar
            if (document.getElementById('sidebarControlMode')) {
                const controlModeName = controlModeNames[data.control_mode] || `Unknown (${data.control_mode})`;
                const inputModeName = inputModeNames[data.input_mode] || `Unknown (${data.input_mode})`;
                document.getElementById('sidebarControlMode').textContent = `${controlModeName} / ${inputModeName}`;
            }

            // Update battery voltage in sidebar
            if (data.bus_voltage !== null && data.bus_voltage !== undefined) {
                const voltage = data.bus_voltage;
                document.getElementById('sidebarVoltage').textContent = voltage.toFixed(2);

                // Update sidebar voltage status badge with new thresholds
                const sidebarVoltageStatus = document.getElementById('sidebarVoltageStatus');
                const sidebarBatteryIcon = document.getElementById('sidebarBatteryIcon');

                if (voltage < 20.4) {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-critical" style="font-size: 0.65rem;">SHUTDOWN</span>';
                    sidebarBatteryIcon.className = 'bi bi-battery-empty';
                    sidebarBatteryIcon.style.color = '#dc3545';  // Red
                } else if (voltage < 21.0) {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-urgent" style="font-size: 0.65rem;">Urgent</span>';
                    sidebarBatteryIcon.className = 'bi bi-battery';
                    sidebarBatteryIcon.style.color = '#fd7e14';  // Orange
                } else if (voltage < 22.2) {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-warning" style="font-size: 0.65rem;">Low</span>';
                    sidebarBatteryIcon.className = 'bi bi-battery-half';
                    sidebarBatteryIcon.style.color = '#ffc107';  // Yellow
                } else if (voltage > 30) {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-critical" style="font-size: 0.65rem;">OV</span>';
                    sidebarBatteryIcon.style.color = '#dc3545';  // Red
                } else if (voltage > 28) {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-high" style="font-size: 0.65rem;">High</span>';
                    sidebarBatteryIcon.className = 'bi bi-battery-charging';
                    sidebarBatteryIcon.style.color = '#fd7e14';  // Orange
                } else {
                    sidebarVoltageStatus.innerHTML = '<span class="badge voltage-normal" style="font-size: 0.65rem;">Good</span>';
                    sidebarBatteryIcon.className = 'bi bi-battery-full';
                    sidebarBatteryIcon.style.color = '#28a745';  // Green
                }
            }

            // Update FET temperature in sidebar
            if (data.fet_temp !== null && data.fet_temp !== undefined) {
                const fetTemp = data.fet_temp;
                document.getElementById('sidebarFetTemp').textContent = fetTemp.toFixed(1);

                // Update sidebar temperature status badge
                const sidebarTempStatus = document.getElementById('sidebarTempStatus');
                const sidebarTempIcon = document.getElementById('sidebarTempIcon');

                if (fetTemp < 40) {
                    sidebarTempStatus.innerHTML = '<span class="badge temp-cool" style="font-size: 0.65rem;">Cool</span>';
                    sidebarTempIcon.style.color = '#17a2b8';  // Cyan
                } else if (fetTemp < 60) {
                    sidebarTempStatus.innerHTML = '<span class="badge temp-normal" style="font-size: 0.65rem;">OK</span>';
                    sidebarTempIcon.style.color = '#28a745';  // Green
                } else if (fetTemp < 80) {
                    sidebarTempStatus.innerHTML = '<span class="badge temp-warm" style="font-size: 0.65rem;">Warm</span>';
                    sidebarTempIcon.style.color = '#ffc107';  // Yellow
                } else if (fetTemp < 100) {
                    sidebarTempStatus.innerHTML = '<span class="badge temp-hot" style="font-size: 0.65rem;">Hot</span>';
                    sidebarTempIcon.style.color = '#fd7e14';  // Orange
                } else {
                    sidebarTempStatus.innerHTML = '<span class="badge temp-critical" style="font-size: 0.65rem;">Critical</span>';
                    sidebarTempIcon.style.color = '#dc3545';  // Red
                }
            }
        });

        // Battery alert socket handlers
        socket.on('battery_alert', function(data) {
            const level = data.level;
            const voltage = data.voltage;
            const message = data.message;

            // Visual log
            const logType = level === 'critical' ? 'danger' :
                            level === 'urgent' ? 'warning' : 'warning';
            addLog(message, logType);

            // Audio alert
            playBatteryAlert(level);

            // Browser notification
            showBatteryNotification(level, message, voltage);

            // Visual flash for critical alerts
            if (level === 'critical') {
                flashCriticalAlert();
            }
        });

        socket.on('battery_state', function(data) {
            const state = data.state;
            const voltage = data.voltage;

            addLog(`Battery state: ${state} (${voltage.toFixed(2)}V)`, 'info');
        });

        socket.on('motor_shutdown', function(data) {
            const reason = data.reason;
            const voltage = data.voltage;

            addLog(`MOTOR SHUTDOWN: ${reason} @ ${voltage.toFixed(2)}V`, 'danger');

            // Show prominent UI indicator
            showMotorShutdownBanner();

            // Critical audio alert
            playBatteryAlert('critical');
        });

        socket.on('motor_blocked', function(data) {
            // Subtle indication that commands are blocked
            addLog(data.message, 'warning');
        });

        // UI Functions
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('statusDot');
            const text = document.getElementById('connectionText');
            if (indicator) {
                if (connected) {
                    indicator.className = 'status-dot';
                    text.textContent = 'Connected';
                } else {
                    indicator.className = 'status-dot disconnected';
                    text.textContent = 'Disconnected';
                }
            }

            // Update sidebar connection status
            const sidebarConnection = document.getElementById('sidebarConnection');
            const sidebarConnectionCard = document.getElementById('sidebarConnectionCard');
            const sidebarConnectionIcon = document.getElementById('sidebarConnectionIcon');

            if (sidebarConnection && sidebarConnectionCard && sidebarConnectionIcon) {
                if (connected) {
                    sidebarConnection.textContent = 'Connected';
                    sidebarConnectionCard.style.borderLeftColor = 'var(--accent-green)';
                    sidebarConnectionIcon.className = 'bi bi-wifi';
                    sidebarConnectionIcon.style.color = 'var(--accent-green)';
                } else {
                    sidebarConnection.textContent = 'Disconnected';
                    sidebarConnectionCard.style.borderLeftColor = '#dc3545';
                    sidebarConnectionIcon.className = 'bi bi-wifi-off';
                    sidebarConnectionIcon.style.color = '#dc3545';
                }
            }
        }

        function updateDisplay(position, velocity) {
            // Handle null/NaN values from uncalibrated encoder
            const posDisplay = (position === null || isNaN(position)) ? 'N/A' : position.toFixed(3);
            const velDisplay = (velocity === null || isNaN(velocity)) ? 'N/A' : velocity.toFixed(3);

            document.getElementById('currentPosition').textContent = posDisplay;
            document.getElementById('currentVelocity').textContent = velDisplay;

            // Update legacy single-motor chart data (Motor 0 for backward compatibility)
            const now = new Date().toLocaleTimeString();

            // Only add new timeLabel if this is a Motor 0 update or single-motor mode
            if (positionDataMotor0.length === timeLabels.length || timeLabels.length === 0) {
                timeLabels.push(now);
            }

            positionData.push((position === null || isNaN(position)) ? 0 : position);
            velocityData.push((velocity === null || isNaN(velocity)) ? 0 : velocity);

            // Update Motor 0 data (since this is called with Motor 0 data from feedback)
            positionDataMotor0.push((position === null || isNaN(position)) ? 0 : position);
            velocityDataMotor0.push((velocity === null || isNaN(velocity)) ? 0 : velocity);

            // Keep only last maxDataPoints
            if (timeLabels.length > maxDataPoints) {
                timeLabels.shift();
                positionData.shift();
                velocityData.shift();
                positionDataMotor0.shift();
                velocityDataMotor0.shift();
                if (positionDataMotor1.length > 0) {
                    positionDataMotor1.shift();
                    velocityDataMotor1.shift();
                }
            }

            positionChart.update();
            velocityChart.update();
        }

        // Update chart data for specific motor (multi-motor mode)
        function updateMotorChartData(motorId, position, velocity) {
            const now = new Date().toLocaleTimeString();

            // Synchronize time labels across all motors
            if (motorId === 0) {
                // Motor 0 controls the time axis
                timeLabels.push(now);
                positionDataMotor0.push((position === null || isNaN(position)) ? 0 : position);
                velocityDataMotor0.push((velocity === null || isNaN(velocity)) ? 0 : velocity);
            } else if (motorId === 1) {
                // Motor 1 follows Motor 0's time axis
                // Pad with last value if Motor 1 is behind
                while (positionDataMotor1.length < positionDataMotor0.length - 1) {
                    const lastPos = positionDataMotor1.length > 0 ? positionDataMotor1[positionDataMotor1.length - 1] : 0;
                    const lastVel = velocityDataMotor1.length > 0 ? velocityDataMotor1[velocityDataMotor1.length - 1] : 0;
                    positionDataMotor1.push(lastPos);
                    velocityDataMotor1.push(lastVel);
                }
                positionDataMotor1.push((position === null || isNaN(position)) ? 0 : position);
                velocityDataMotor1.push((velocity === null || isNaN(velocity)) ? 0 : velocity);
            }

            // Keep only last maxDataPoints
            if (timeLabels.length > maxDataPoints) {
                timeLabels.shift();
                positionDataMotor0.shift();
                velocityDataMotor0.shift();
                if (positionDataMotor1.length > 0) {
                    positionDataMotor1.shift();
                    velocityDataMotor1.shift();
                }
            }

            // Only update charts if this is Motor 0 (to avoid double-updating)
            if (motorId === 0) {
                positionChart.update();
                velocityChart.update();
            }
        }

        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();

            // Update original log div (for backwards compatibility)
            const logDiv = document.getElementById('logMessages');
            if (logDiv) {
                const colorClass = type === 'danger' ? 'text-danger' :
                                  type === 'success' ? 'text-success' :
                                  type === 'warning' ? 'text-warning' : 'text-info';
                logDiv.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            // Update persistent log panel
            const persistentLog = document.getElementById('persistentLogContent');
            if (persistentLog) {
                const entry = document.createElement('div');
                entry.className = `persistent-log-entry ${type}`;
                entry.textContent = `[${timestamp}] ${message}`;
                persistentLog.appendChild(entry);

                // Auto-scroll to bottom
                persistentLog.scrollTop = persistentLog.scrollHeight;

                // Limit number of entries
                const entries = persistentLog.querySelectorAll('.persistent-log-entry');
                if (entries.length > maxPersistentLogs) {
                    entries[0].remove();
                }

                // Update badge count
                logCount++;
                const badge = document.getElementById('logPanelBadge');
                if (badge) {
                    badge.textContent = logCount;

                    // Flash badge on new entry
                    badge.classList.add('bg-primary');
                    setTimeout(() => badge.classList.replace('bg-primary', 'bg-secondary'), 500);
                }
            }
        }

        function toggleLogPanel() {
            const panel = document.getElementById('persistentLogPanel');
            if (panel) {
                panel.classList.toggle('collapsed');
                panel.classList.toggle('expanded');

                const chevron = document.getElementById('logPanelChevron');
                if (chevron) {
                    if (panel.classList.contains('expanded')) {
                        chevron.className = 'bi bi-chevron-down';
                    } else {
                        chevron.className = 'bi bi-chevron-up';
                    }
                }

                // Reset badge count when opened
                if (panel.classList.contains('expanded')) {
                    logCount = 0;
                    const badge = document.getElementById('logPanelBadge');
                    if (badge) badge.textContent = '0';
                }
            }
        }

        function updateVelocityDisplay(value) {
            document.getElementById('velocityValue').textContent = parseFloat(value).toFixed(1);
        }

        function setVelocity(value) {
            document.getElementById('velocitySlider').value = value;
            updateVelocityDisplay(value);
        }

        function adjustVelocity(delta) {
            const slider = document.getElementById('velocitySlider');
            const newValue = parseFloat(slider.value) + delta;
            const clampedValue = Math.max(-10, Math.min(10, newValue));
            setVelocity(clampedValue);
        }

        function applyVelocity() {
            const velocity = parseFloat(document.getElementById('velocitySlider').value);
            socket.emit('set_velocity', { velocity: velocity });
            addLog(`Setting velocity: ${velocity.toFixed(2)} turns/sec`, 'info');
        }

        function emergencyStop() {
            socket.emit('stop');
            setVelocity(0);
            addLog('EMERGENCY STOP activated', 'danger');
        }

        function enableMotor(motorId) {
            if (motorId === undefined) {
                // Legacy single-motor support
                addLog('Enabling motor - this will take ~6 seconds for calibration...', 'info');
                socket.emit('enable_motor');
            } else {
                // Multi-motor support
                addLog(`Enabling Motor ${motorId} - this will take ~6 seconds for calibration...`, 'info');
                socket.emit('enable_motor_id', { motor_id: motorId });
            }
        }

        function disableMotor(motorId) {
            if (motorId === undefined) {
                // Legacy single-motor support
                addLog('Disabling motor...', 'info');
                socket.emit('disable_motor');
            } else {
                // Multi-motor support
                addLog(`Disabling Motor ${motorId}...`, 'info');
                socket.emit('disable_motor_id', { motor_id: motorId });
            }
        }

        // Position command debouncing
        let lastPositionCommandTime = 0;
        const POSITION_COMMAND_COOLDOWN = 1000;  // 1 second minimum between commands

        function goToPosition() {
            const position = parseFloat(document.getElementById('positionInput').value);
            if (isNaN(position)) {
                addLog('Invalid position value', 'warning');
                return;
            }

            // Prevent rapid repeated commands (debouncing)
            const now = Date.now();
            if (now - lastPositionCommandTime < POSITION_COMMAND_COOLDOWN) {
                const remaining = ((POSITION_COMMAND_COOLDOWN - (now - lastPositionCommandTime)) / 1000).toFixed(1);
                addLog(`Please wait ${remaining}s before sending another position command`, 'warning');
                return;
            }

            lastPositionCommandTime = now;
            // Apply scaling factor
            const scaledPosition = position * positionScaleFactor;
            socket.emit('set_position', { position: scaledPosition });
            addLog(`Moving to position: ${position.toFixed(2)} turns (scaled: ${scaledPosition.toFixed(2)})`, 'info');
        }

        // Multi-Motor Control Functions
        function switchMotorTab(motorId, tab) {
            // Hide all tabs for this motor
            document.querySelectorAll(`#motor${motorId}-tab-velocity, #motor${motorId}-tab-position`).forEach(el => {
                el.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`motor${motorId}-tab-${tab}`).classList.add('active');

            // Update tab buttons for this motor
            const motorPanel = document.querySelector(`.motor-panel-${motorId}`);
            if (motorPanel) {
                motorPanel.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            }
        }

        function updateMotorVelocityDisplay(motorId, value) {
            document.getElementById(`motor${motorId}-velocityValue`).textContent = parseFloat(value).toFixed(1);
        }

        function applyMotorVelocity(motorId) {
            const velocity = parseFloat(document.getElementById(`motor${motorId}-velocitySlider`).value);
            socket.emit('set_velocity_motor', { motor_id: motorId, velocity: velocity });
            addLog(`Setting Motor ${motorId} velocity: ${velocity.toFixed(2)} turns/sec`, 'info');
        }

        let lastMotorPositionCommandTime = [0, 0]; // Track per motor
        const MOTOR_POSITION_COMMAND_COOLDOWN = 1000;

        function goToMotorPosition(motorId) {
            const position = parseFloat(document.getElementById(`motor${motorId}-positionInput`).value);
            if (isNaN(position)) {
                addLog(`Invalid position value for Motor ${motorId}`, 'warning');
                return;
            }

            // Prevent rapid repeated commands per motor
            const now = Date.now();
            if (now - lastMotorPositionCommandTime[motorId] < MOTOR_POSITION_COMMAND_COOLDOWN) {
                const remaining = ((MOTOR_POSITION_COMMAND_COOLDOWN - (now - lastMotorPositionCommandTime[motorId])) / 1000).toFixed(1);
                addLog(`Please wait ${remaining}s before sending another position command to Motor ${motorId}`, 'warning');
                return;
            }

            lastMotorPositionCommandTime[motorId] = now;
            socket.emit('set_position_motor', { motor_id: motorId, position: position });
            addLog(`Moving Motor ${motorId} to position: ${position.toFixed(2)} turns`, 'info');
        }

        function applyCoordinatedPosition() {
            const joint0 = parseFloat(document.getElementById('coord-joint0').value);
            const joint1 = parseFloat(document.getElementById('coord-joint1').value);

            if (isNaN(joint0) || isNaN(joint1)) {
                addLog('Invalid joint positions - please enter valid numbers for both joints', 'warning');
                return;
            }

            socket.emit('set_joint_angles', { joints: [joint0, joint1] });
            addLog(`Executing coordinated move: Joint0=${joint0.toFixed(2)}, Joint1=${joint1.toFixed(2)}`, 'info');
        }

        function stopAllMotors() {
            socket.emit('stop_all');
            addLog('Stopping all motors (STOPALL command)', 'warning');
        }

        function setControlMode() {
            const controlMode = parseInt(document.getElementById('controlModeSelect').value);
            const inputMode = parseInt(document.getElementById('inputModeSelect').value);

            addLog(`Setting control mode: ${controlMode}, input mode: ${inputMode}`, 'info');

            socket.emit('set_control_mode', {
                control_mode: controlMode,
                input_mode: inputMode
            });

            // Save to localStorage so it persists across page refreshes
            localStorage.setItem('savedControlMode', controlMode);
            localStorage.setItem('savedInputMode', inputMode);
            addLog('Control mode preference saved', 'success');
        }

        function restoreSavedControlMode() {
            // Restore saved control mode from localStorage
            const savedControlMode = localStorage.getItem('savedControlMode');
            const savedInputMode = localStorage.getItem('savedInputMode');

            if (savedControlMode !== null && savedInputMode !== null) {
                const controlMode = parseInt(savedControlMode);
                const inputMode = parseInt(savedInputMode);

                // Update UI selects
                const controlSelect = document.getElementById('controlModeSelect');
                const inputSelect = document.getElementById('inputModeSelect');
                if (controlSelect) controlSelect.value = controlMode;
                if (inputSelect) inputSelect.value = inputMode;

                // Reapply the saved mode to ODrive
                addLog(`Restoring saved control mode: ${controlMode}, input mode: ${inputMode}`, 'info');
                socket.emit('set_control_mode', {
                    control_mode: controlMode,
                    input_mode: inputMode
                });
            }
        }

        function clearSavedControlMode() {
            // Clear saved control mode from localStorage
            localStorage.removeItem('savedControlMode');
            localStorage.removeItem('savedInputMode');

            // Reset UI selects to default (VELOCITY_CONTROL, VEL_RAMP)
            const controlSelect = document.getElementById('controlModeSelect');
            const inputSelect = document.getElementById('inputModeSelect');
            if (controlSelect) controlSelect.value = 2;  // VELOCITY_CONTROL
            if (inputSelect) inputSelect.value = 2;      // VEL_RAMP

            addLog('Saved control mode cleared. Page will use Arduino defaults on next refresh.', 'success');
        }

        function requestConfig() {
            socket.emit('get_config');
        }

        // Position updates come automatically via FEEDBACK messages from Arduino
        // No need to poll - Arduino sends feedback every 100ms

        // Load saved scale factor from localStorage (default to 1.0)
        window.addEventListener('DOMContentLoaded', function() {
            const saved = localStorage.getItem('positionScaleFactor');
            let scaleFactor = 1.0;  // Default to 1.0x

            if (saved) {
                const parsedValue = parseFloat(saved);
                // Validate saved value is within reasonable range (0.1 to 20)
                if (!isNaN(parsedValue) && parsedValue >= 0.1 && parsedValue <= 20) {
                    scaleFactor = parsedValue;
                    addLog(`Loaded saved position scale factor: ${scaleFactor}x`, 'info');
                } else {
                    addLog(`Invalid saved scale factor (${saved}), defaulting to 1.0x`, 'warning');
                    localStorage.removeItem('positionScaleFactor');
                }
            } else {
                addLog(`Position scale factor set to default: 1.0x`, 'info');
            }

            // Update UI with validated or default value
            positionScaleFactor = scaleFactor;
            document.getElementById('positionScaleFactor').value = scaleFactor;
            document.getElementById('scaleFactorValue').textContent = scaleFactor.toFixed(1);
        });

        // Initialize
        addLog('System initialized', 'success');

        // ========== JOYSTICK CONTROL ==========

        // Joystick Canvas Setup
        const joystickCanvas = document.getElementById('joystickCanvas');
        const joystickCtx = joystickCanvas.getContext('2d');
        const joystickRadius = 130; // Radius of joystick pad
        const joystickCenter = { x: 140, y: 140 }; // Center of 280x280 canvas

        // Joystick state
        let joystickActive = false;
        let currentJoystickAngle = 0;
        let currentJoystickPosition = { x: 0, y: 0 };
        let lastPositionUpdateTime = 0;
        const POSITION_UPDATE_THROTTLE = 50; // ms (20Hz update rate)

        // Draw joystick interface
        function drawJoystick() {
            // Clear canvas
            joystickCtx.clearRect(0, 0, joystickCanvas.width, joystickCanvas.height);

            // Draw outer circle (pad boundary)
            joystickCtx.beginPath();
            joystickCtx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI);
            joystickCtx.strokeStyle = '#6c757d';
            joystickCtx.lineWidth = 2;
            joystickCtx.stroke();
            joystickCtx.fillStyle = '#ffffff';
            joystickCtx.fill();

            // Draw crosshairs (cardinal directions)
            joystickCtx.strokeStyle = '#dee2e6';
            joystickCtx.lineWidth = 1;

            // Horizontal line
            joystickCtx.beginPath();
            joystickCtx.moveTo(joystickCenter.x - joystickRadius, joystickCenter.y);
            joystickCtx.lineTo(joystickCenter.x + joystickRadius, joystickCenter.y);
            joystickCtx.stroke();

            // Vertical line
            joystickCtx.beginPath();
            joystickCtx.moveTo(joystickCenter.x, joystickCenter.y - joystickRadius);
            joystickCtx.lineTo(joystickCenter.x, joystickCenter.y + joystickRadius);
            joystickCtx.stroke();

            // Draw center point
            joystickCtx.beginPath();
            joystickCtx.arc(joystickCenter.x, joystickCenter.y, 5, 0, 2 * Math.PI);
            joystickCtx.fillStyle = '#6c757d';
            joystickCtx.fill();

            // Draw angle labels
            joystickCtx.fillStyle = '#6c757d';
            joystickCtx.font = '12px Arial';
            joystickCtx.textAlign = 'center';
            joystickCtx.fillText('0Â°', joystickCenter.x + joystickRadius + 15, joystickCenter.y + 5);
            joystickCtx.fillText('90Â°', joystickCenter.x, joystickCenter.y - joystickRadius - 10);
            joystickCtx.fillText('180Â°', joystickCenter.x - joystickRadius - 20, joystickCenter.y + 5);
            joystickCtx.fillText('270Â°', joystickCenter.x, joystickCenter.y + joystickRadius + 20);

            // If joystick is active, draw cursor position
            if (joystickActive) {
                // Draw line from center to cursor
                joystickCtx.beginPath();
                joystickCtx.moveTo(joystickCenter.x, joystickCenter.y);
                joystickCtx.lineTo(currentJoystickPosition.x, currentJoystickPosition.y);
                joystickCtx.strokeStyle = '#0d6efd';
                joystickCtx.lineWidth = 2;
                joystickCtx.stroke();

                // Draw cursor point
                joystickCtx.beginPath();
                joystickCtx.arc(currentJoystickPosition.x, currentJoystickPosition.y, 8, 0, 2 * Math.PI);
                joystickCtx.fillStyle = '#0d6efd';
                joystickCtx.fill();
                joystickCtx.strokeStyle = '#ffffff';
                joystickCtx.lineWidth = 2;
                joystickCtx.stroke();
            }
        }

        // Convert canvas coordinates to angle and position
        function canvasToAnglePosition(canvasX, canvasY) {
            // Get offset from center
            const dx = canvasX - joystickCenter.x;
            const dy = -(canvasY - joystickCenter.y); // Invert Y (canvas Y increases downward)

            // Calculate angle using atan2 (returns radians: -Ï€ to Ï€)
            // atan2(y, x) gives angle where 0 = right, Ï€/2 = up
            let angleRadians = Math.atan2(dy, dx);

            // Convert to degrees
            let angleDegrees = angleRadians * (180 / Math.PI);

            // Normalize to 0-360 range
            if (angleDegrees < 0) {
                angleDegrees += 360;
            }

            // Convert angle to motor position (turns)
            // 360Â° = 1 turn
            const positionTurns = angleDegrees / 360;

            return {
                angle: angleDegrees,
                position: positionTurns,
                x: canvasX,
                y: canvasY
            };
        }

        // Clamp point to circle boundary
        function clampToCircle(x, y) {
            const dx = x - joystickCenter.x;
            const dy = y - joystickCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= joystickRadius) {
                return { x, y };
            }

            // Scale to circle edge
            const scale = joystickRadius / distance;
            return {
                x: joystickCenter.x + dx * scale,
                y: joystickCenter.y + dy * scale
            };
        }

        // Get canvas coordinates from event (handles both mouse and touch)
        function getCanvasCoordinates(event) {
            const rect = joystickCanvas.getBoundingClientRect();

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Mouse/touch down - start tracking
        function onJoystickStart(event) {
            event.preventDefault();
            joystickActive = true;

            const coords = getCanvasCoordinates(event);
            const clamped = clampToCircle(coords.x, coords.y);
            currentJoystickPosition = clamped;

            const result = canvasToAnglePosition(clamped.x, clamped.y);
            currentJoystickAngle = result.angle;

            updateJoystickDisplay(result.angle, result.position);
            sendThrottledPosition(result.position);
            drawJoystick();
        }

        // Mouse/touch move - update position
        function onJoystickMove(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const coords = getCanvasCoordinates(event);
            const clamped = clampToCircle(coords.x, coords.y);
            currentJoystickPosition = clamped;

            const result = canvasToAnglePosition(clamped.x, clamped.y);
            currentJoystickAngle = result.angle;

            updateJoystickDisplay(result.angle, result.position);
            sendThrottledPosition(result.position);
            drawJoystick();
        }

        // Mouse/touch up - stop tracking
        function onJoystickEnd(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const holdPosition = document.getElementById('joystickHoldPosition').checked;

            if (!holdPosition) {
                // Return to center (position 0)
                socket.emit('set_position', { position: 0 });
                addLog('Joystick released - returning to position 0', 'info');
                currentJoystickAngle = 0;
                updateJoystickDisplay(0, 0);
            } else {
                addLog(`Joystick released - holding position ${currentJoystickAngle.toFixed(1)}Â°`, 'info');
            }

            joystickActive = false;
            drawJoystick();
        }

        // Throttled position sending
        function sendThrottledPosition(position) {
            const now = Date.now();
            if (now - lastPositionUpdateTime >= POSITION_UPDATE_THROTTLE) {
                // Apply scaling factor
                const scaledPosition = position * positionScaleFactor;
                socket.emit('set_position', { position: scaledPosition });
                lastPositionUpdateTime = now;
            }
        }

        // Update display elements
        function updateJoystickDisplay(angle, position) {
            document.getElementById('joystickAngle').textContent = angle.toFixed(1);
            document.getElementById('joystickPosition').textContent = position.toFixed(3);
        }

        // Register event listeners for joystick
        joystickCanvas.addEventListener('mousedown', onJoystickStart);
        joystickCanvas.addEventListener('mousemove', onJoystickMove);
        joystickCanvas.addEventListener('mouseup', onJoystickEnd);
        joystickCanvas.addEventListener('mouseleave', onJoystickEnd);

        // Touch events for mobile
        joystickCanvas.addEventListener('touchstart', onJoystickStart);
        joystickCanvas.addEventListener('touchmove', onJoystickMove);
        joystickCanvas.addEventListener('touchend', onJoystickEnd);
        joystickCanvas.addEventListener('touchcancel', onJoystickEnd);

        // Initial draw
        drawJoystick();

        // ========== ROTATION KNOB CONTROL ==========

        // Rotation Knob State Variables
        let rotationKnobActive = false;           // Currently dragging
        let cumulativeRotation = 0;               // Total rotation in degrees (unlimited)
        let lastDragAngle = 0;                    // Last cursor angle during drag
        let rotationZeroPosition = 0;             // Calibration offset (in turns)
        let lastRotationUpdateTime = 0;           // For throttling
        let initializedRotationKnob = false;      // Synced with motor position
        let currentMotorPosition = 0;             // Track current motor position from feedback
        const ROTATION_UPDATE_THROTTLE = 300;     // ms (3Hz updates - slower for smooth tracking with POS_FILTER)
        let lastSentPosition = null;              // Track last sent position to avoid duplicates
        const POSITION_DEADBAND = 0.001;          // Minimum change in turns before sending update

        // SVG element references
        let rotationKnobSvg = null;
        let knobPointer = null;
        let knobGripGroup = null;

        // Create SVG Rotation Knob
        function createRotationKnob() {
            const container = document.getElementById('rotationKnobContainer');
            const svgNS = "http://www.w3.org/2000/svg";

            // Create SVG element
            rotationKnobSvg = document.createElementNS(svgNS, 'svg');
            rotationKnobSvg.setAttribute('width', '200');
            rotationKnobSvg.setAttribute('height', '200');
            rotationKnobSvg.setAttribute('id', 'rotationKnobSvg');
            rotationKnobSvg.setAttribute('viewBox', '0 0 200 200');

            // Create gradient for 3D effect
            const defs = document.createElementNS(svgNS, 'defs');
            const gradient = document.createElementNS(svgNS, 'radialGradient');
            gradient.setAttribute('id', 'knobGradient');
            gradient.setAttribute('cx', '40%');
            gradient.setAttribute('cy', '40%');

            const stop1 = document.createElementNS(svgNS, 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('style', 'stop-color:#e9ecef;stop-opacity:1');

            const stop2 = document.createElementNS(svgNS, 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('style', 'stop-color:#adb5bd;stop-opacity:1');

            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            rotationKnobSvg.appendChild(defs);

            // Create knob body (circle)
            const knobBody = document.createElementNS(svgNS, 'circle');
            knobBody.setAttribute('cx', '100');
            knobBody.setAttribute('cy', '100');
            knobBody.setAttribute('r', '80');
            knobBody.setAttribute('class', 'knob-body');
            knobBody.setAttribute('fill', 'url(#knobGradient)');  // Apply gradient
            knobBody.setAttribute('stroke', '#495057');           // Dark border
            knobBody.setAttribute('stroke-width', '2');
            rotationKnobSvg.appendChild(knobBody);

            // Create grip lines (radial pattern)
            knobGripGroup = document.createElementNS(svgNS, 'g');
            knobGripGroup.setAttribute('id', 'knobGripGroup');

            for (let i = 0; i < 8; i++) {
                const angle = (i * 45) * (Math.PI / 180);
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', 100 + Math.cos(angle) * 50);
                line.setAttribute('y1', 100 + Math.sin(angle) * 50);
                line.setAttribute('x2', 100 + Math.cos(angle) * 70);
                line.setAttribute('y2', 100 + Math.sin(angle) * 70);
                line.setAttribute('class', 'knob-grip-line');
                line.setAttribute('stroke', '#343a40');      // Dark gray grip lines
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-linecap', 'round');
                knobGripGroup.appendChild(line);
            }
            rotationKnobSvg.appendChild(knobGripGroup);

            // Create reference mark at 0Â° (12 o'clock)
            const referenceMark = document.createElementNS(svgNS, 'circle');
            referenceMark.setAttribute('cx', '100');
            referenceMark.setAttribute('cy', '15');
            referenceMark.setAttribute('r', '5');
            referenceMark.setAttribute('class', 'knob-reference-mark');
            referenceMark.setAttribute('fill', '#0d6efd');    // Blue reference dot
            referenceMark.setAttribute('stroke', 'white');
            referenceMark.setAttribute('stroke-width', '1');
            rotationKnobSvg.appendChild(referenceMark);

            // Create pointer line (rotates with knob)
            knobPointer = document.createElementNS(svgNS, 'line');
            knobPointer.setAttribute('x1', '100');
            knobPointer.setAttribute('y1', '100');
            knobPointer.setAttribute('x2', '100');
            knobPointer.setAttribute('y2', '30');
            knobPointer.setAttribute('class', 'knob-pointer');
            knobPointer.setAttribute('id', 'knobPointer');
            knobPointer.setAttribute('stroke', '#0d6efd');    // Blue pointer
            knobPointer.setAttribute('stroke-width', '4');
            knobPointer.setAttribute('stroke-linecap', 'round');
            rotationKnobSvg.appendChild(knobPointer);

            // Add to container
            container.appendChild(rotationKnobSvg);

            // Register event listeners
            rotationKnobSvg.addEventListener('mousedown', onRotationKnobMouseDown);
            rotationKnobSvg.addEventListener('touchstart', onRotationKnobTouchStart);
        }

        // Get angle from cursor position relative to knob center
        function getAngleFromCursor(clientX, clientY) {
            const rect = rotationKnobSvg.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = clientX - centerX;
            const dy = clientY - centerY;

            // Calculate angle in degrees (0Â° = top, clockwise)
            let angle = Math.atan2(dx, -dy) * (180 / Math.PI);
            if (angle < 0) angle += 360;

            return angle;
        }

        // Calculate angle delta handling wraparound
        function calculateAngleDelta(newAngle, oldAngle) {
            let delta = newAngle - oldAngle;

            // Handle wraparound at 0Â°/360Â° boundary
            if (delta > 180) {
                delta -= 360;  // Clockwise wrap
            } else if (delta < -180) {
                delta += 360;  // Counter-clockwise wrap
            }

            return delta;
        }

        // Mouse event handlers
        function onRotationKnobMouseDown(event) {
            event.preventDefault();
            rotationKnobActive = true;
            lastDragAngle = getAngleFromCursor(event.clientX, event.clientY);

            document.addEventListener('mousemove', onRotationKnobMouseMove);
            document.addEventListener('mouseup', onRotationKnobMouseUp);
        }

        function onRotationKnobMouseMove(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            const newAngle = getAngleFromCursor(event.clientX, event.clientY);
            const delta = calculateAngleDelta(newAngle, lastDragAngle);
            cumulativeRotation += delta;
            lastDragAngle = newAngle;

            updateRotationKnobDisplay();

            // Send position updates during drag with throttling (10Hz max)
            const now = Date.now();
            if (now - lastRotationUpdateTime > ROTATION_UPDATE_THROTTLE) {
                sendRotationPosition();
                lastRotationUpdateTime = now;
            }
        }

        function onRotationKnobMouseUp(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            rotationKnobActive = false;
            sendRotationPosition();  // Final position update

            document.removeEventListener('mousemove', onRotationKnobMouseMove);
            document.removeEventListener('mouseup', onRotationKnobMouseUp);
        }

        // Touch event handlers
        function onRotationKnobTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 0) return;

            rotationKnobActive = true;
            const touch = event.touches[0];
            lastDragAngle = getAngleFromCursor(touch.clientX, touch.clientY);

            document.addEventListener('touchmove', onRotationKnobTouchMove);
            document.addEventListener('touchend', onRotationKnobTouchEnd);
            document.addEventListener('touchcancel', onRotationKnobTouchEnd);
        }

        function onRotationKnobTouchMove(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();
            if (event.touches.length === 0) return;

            const touch = event.touches[0];
            const newAngle = getAngleFromCursor(touch.clientX, touch.clientY);
            const delta = calculateAngleDelta(newAngle, lastDragAngle);
            cumulativeRotation += delta;
            lastDragAngle = newAngle;

            updateRotationKnobDisplay();

            // Send position updates during drag with throttling (10Hz max)
            const now = Date.now();
            if (now - lastRotationUpdateTime > ROTATION_UPDATE_THROTTLE) {
                sendRotationPosition();
                lastRotationUpdateTime = now;
            }
        }

        function onRotationKnobTouchEnd(event) {
            if (!rotationKnobActive) return;
            event.preventDefault();

            rotationKnobActive = false;
            sendRotationPosition();  // Final position update

            document.removeEventListener('touchmove', onRotationKnobTouchMove);
            document.removeEventListener('touchend', onRotationKnobTouchEnd);
            document.removeEventListener('touchcancel', onRotationKnobTouchEnd);
        }

        // Update rotation knob visual display
        function updateRotationKnobDisplay() {
            // Update SVG pointer rotation
            if (knobPointer) {
                knobPointer.setAttribute('transform', `rotate(${cumulativeRotation} 100 100)`);
            }

            // Also rotate grip lines for better visual feedback
            if (knobGripGroup) {
                knobGripGroup.setAttribute('transform', `rotate(${cumulativeRotation} 100 100)`);
            }

            // Update text displays
            const normalizedDegrees = ((cumulativeRotation % 360) + 360) % 360;
            const turns = cumulativeRotation / 360;
            const rotationCount = Math.floor(Math.abs(cumulativeRotation) / 360);

            const degreesEl = document.getElementById('rotationDegrees');
            const turnsEl = document.getElementById('rotationTurns');
            const countEl = document.getElementById('rotationCount');

            if (degreesEl) degreesEl.textContent = normalizedDegrees.toFixed(1);
            if (turnsEl) turnsEl.textContent = turns.toFixed(3);
            if (countEl) countEl.textContent = rotationCount;
        }

        // Send rotation position to motor
        function sendRotationPosition() {
            const turns = cumulativeRotation / 360;
            const absolutePosition = rotationZeroPosition + turns;
            // Apply scaling factor
            const scaledPosition = absolutePosition * positionScaleFactor;

            // Check if position has changed enough to warrant sending (deadband)
            if (lastSentPosition !== null && Math.abs(scaledPosition - lastSentPosition) < POSITION_DEADBAND) {
                console.log(`Position change too small: ${Math.abs(scaledPosition - lastSentPosition).toFixed(4)} < ${POSITION_DEADBAND}`);
                return;  // Skip update if change is too small
            }

            lastSentPosition = scaledPosition;
            console.log(`[KNOB] degrees:${cumulativeRotation.toFixed(1)}Â° â†’ turns:${turns.toFixed(3)} + zero:${rotationZeroPosition.toFixed(3)} = ${absolutePosition.toFixed(3)} * scale:${positionScaleFactor}x = ${scaledPosition.toFixed(3)} turns`);
            socket.emit('set_position', { position: scaledPosition });
        }

        // Calibration: Set current motor position as zero reference
        function setRotationZero() {
            // Set current motor position as the new zero reference
            if (typeof currentMotorPosition !== 'undefined' && currentMotorPosition !== null) {
                rotationZeroPosition = currentMotorPosition;
                cumulativeRotation = 0;
                updateRotationKnobDisplay();
                addLog(`Set current position (${currentMotorPosition.toFixed(3)} turns) as zero reference`, 'success');
            } else {
                addLog('Cannot set zero: No motor position available', 'warning');
            }
        }

        // Reset: Return to calibrated zero position
        function resetRotationToZero() {
            // Move motor back to the calibrated zero position
            if (typeof rotationZeroPosition !== 'undefined' && rotationZeroPosition !== null) {
                cumulativeRotation = 0;
                updateRotationKnobDisplay();
                sendRotationPosition();
                addLog(`Returning to zero reference (${rotationZeroPosition.toFixed(3)} turns)`, 'info');
            } else {
                addLog('No zero reference set. Use "Set Current as Zero" first.', 'warning');
            }
        }

        // 2D Robot Arm Visualizer
        const robotVisualizer = {
            canvas: document.getElementById('robotCanvas'),
            ctx: null,
            // Robot configuration (from robot_config_2dof_test.json)
            linkLengths: [0.3, 0.25],  // meters (a parameters from DH)
            jointAngles: [0.0, 0.0],    // radians
            scale: 400,                 // pixels per meter
            centerX: 140,
            centerY: 220,

            init() {
                this.ctx = this.canvas.getContext('2d');
                this.draw();
            },

            // Forward kinematics: compute end effector position
            computeFK(j0, j1) {
                const L1 = this.linkLengths[0];
                const L2 = this.linkLengths[1];

                // Joint 0 position (end of link 1)
                const x1 = L1 * Math.cos(j0);
                const y1 = L1 * Math.sin(j0);

                // End effector position (end of link 2)
                const x2 = x1 + L2 * Math.cos(j0 + j1);
                const y2 = y1 + L2 * Math.sin(j0 + j1);

                return { x1, y1, x2, y2 };
            },

            // Convert world coordinates to canvas coordinates
            worldToCanvas(x, y) {
                return {
                    x: this.centerX + x * this.scale,
                    y: this.centerY - y * this.scale  // Flip Y axis
                };
            },

            draw() {
                const ctx = this.ctx;
                const canvas = this.canvas;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw workspace boundary circle (approximate reach)
                const maxReach = this.linkLengths[0] + this.linkLengths[1];
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, maxReach * this.scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);

                // Compute joint and end effector positions
                const fk = this.computeFK(this.jointAngles[0], this.jointAngles[1]);
                const base = this.worldToCanvas(0, 0);
                const joint1 = this.worldToCanvas(fk.x1, fk.y1);
                const endEffector = this.worldToCanvas(fk.x2, fk.y2);

                // Draw link 1
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(base.x, base.y);
                ctx.lineTo(joint1.x, joint1.y);
                ctx.stroke();

                // Draw link 2
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(joint1.x, joint1.y);
                ctx.lineTo(endEffector.x, endEffector.y);
                ctx.stroke();

                // Draw base (fixed)
                ctx.fillStyle = '#757575';
                ctx.beginPath();
                ctx.arc(base.x, base.y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw joint 1
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.arc(joint1.x, joint1.y, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Draw end effector
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(endEffector.x, endEffector.y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw axes
                ctx.strokeStyle = '#9E9E9E';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                // X axis
                ctx.beginPath();
                ctx.moveTo(0, this.centerY);
                ctx.lineTo(canvas.width, this.centerY);
                ctx.stroke();
                // Y axis
                ctx.beginPath();
                ctx.moveTo(this.centerX, 0);
                ctx.lineTo(this.centerX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);

                // Update end effector position display
                document.getElementById('endEffectorPos').textContent =
                    `End Effector: (${fk.x2.toFixed(3)}, ${fk.y2.toFixed(3)}) m`;
            },

            updateJointAngles(angles) {
                this.jointAngles = angles;
                this.draw();
            }
        };

        // Initialize visualizer on page load
        robotVisualizer.init();

        // IK Control Functions
        // Joint slider input handlers
        document.getElementById('joint0Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint0Value').textContent = value.toFixed(3);
            // Update visualizer with slider values
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            robotVisualizer.updateJointAngles([value, j1]);
        });

        document.getElementById('joint1Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint1Value').textContent = value.toFixed(3);
            // Update visualizer with slider values
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            robotVisualizer.updateJointAngles([j0, value]);
        });

        document.getElementById('joint2Slider').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('joint2Value').textContent = value.toFixed(3);
            // Update visualizer with slider values (3-DOF mode)
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            robotVisualizer.updateJointAngles([j0, j1, value]);
        });

        // Set joint angles for multi-motor control
        function setJointAngles() {
            const j0 = parseFloat(document.getElementById('joint0Slider').value);
            const j1 = parseFloat(document.getElementById('joint1Slider').value);
            const j2 = parseFloat(document.getElementById('joint2Slider').value);

            const config = document.getElementById('robotConfigSelect').value;

            if (config === 'single') {
                // Single motor mode - use existing position control
                const scaledPos = j0 * positionScaleFactor;
                socket.emit('set_position', { position: scaledPos });
                addLog(`Setting position to ${j0.toFixed(3)} rad (scaled: ${scaledPos.toFixed(3)})`, 'info');
            } else if (config === '2dof') {
                // 2-DOF mode
                socket.emit('set_joint_angles', { joints: [j0, j1] });
                addLog(`Setting joint angles: J0=${j0.toFixed(3)}, J1=${j1.toFixed(3)} rad`, 'info');
            } else if (config === '3dof' || config === '6dof') {
                // 3-DOF or 6-DOF mode (currently only 3 joints)
                socket.emit('set_joint_angles', { joints: [j0, j1, j2] });
                addLog(`Setting joint angles: J0=${j0.toFixed(3)}, J1=${j1.toFixed(3)}, J2=${j2.toFixed(3)} rad`, 'info');
            }
        }

        // Robot configuration dropdown handler
        document.getElementById('robotConfigSelect').addEventListener('change', function(e) {
            const config = e.target.value;
            addLog(`Robot configuration: ${config}`, 'info');

            // Show/hide controls based on config
            const cartesianControls = document.getElementById('cartesianControls');
            const joint1Container = document.getElementById('joint1Slider').parentElement;
            const joint2Container = document.getElementById('joint2Container');

            if (config === 'single') {
                // Single motor - show only J0
                joint1Container.style.display = 'none';
                joint2Container.style.display = 'none';
                cartesianControls.style.display = 'none';
            } else if (config === '2dof') {
                // 2-DOF - show J0 and J1
                joint1Container.style.display = 'block';
                joint2Container.style.display = 'none';
                cartesianControls.style.display = 'none';
            } else if (config === '3dof' || config === '6dof') {
                // 3-DOF or 6-DOF - show all joints and enable Cartesian controls
                joint1Container.style.display = 'block';
                joint2Container.style.display = 'block';
                cartesianControls.style.display = 'block';
            }
        });

        // Cartesian control - move to X, Y, Z target using IK
        function moveToCartesianTarget() {
            const x = parseFloat(document.getElementById('xSlider').value);
            const y = parseFloat(document.getElementById('ySlider').value);
            const z = parseFloat(document.getElementById('zSlider').value);

            const config = document.getElementById('robotConfigSelect').value;

            if (config !== '3dof' && config !== '6dof') {
                addLog('Cartesian control requires 3-DOF or 6-DOF configuration', 'warning');
                return;
            }

            // Send Cartesian target to backend (IK will be computed there)
            socket.emit('set_cartesian_target', {
                x: x,
                y: y,
                z: z,
                config: config
            });

            addLog(`Moving to Cartesian target: X=${x.toFixed(3)}, Y=${y.toFixed(3)}, Z=${z.toFixed(3)} m`, 'info');
            document.getElementById('ikStatus').textContent = 'Computing IK...';
            document.getElementById('ikStatus').className = 'badge bg-warning';
        }

        // Cartesian slider input handlers
        document.getElementById('xSlider').addEventListener('input', function(e) {
            document.getElementById('targetX').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('ySlider').addEventListener('input', function(e) {
            document.getElementById('targetY').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('zSlider').addEventListener('input', function(e) {
            document.getElementById('targetZ').textContent = parseFloat(e.target.value).toFixed(3);
        });

        // Mode switching function
        function switchControlMode(mode) {
            document.getElementById('velocityControls').style.display =
                mode === 'velocity' ? 'block' : 'none';
            document.getElementById('joystickControls').style.display =
                mode === 'joystick' ? 'block' : 'none';
            document.getElementById('rotationControls').style.display =
                mode === 'rotation' ? 'block' : 'none';
            document.getElementById('ikControls').style.display =
                mode === 'ik' ? 'block' : 'none';
        }

        // Register mode switcher listeners
        document.querySelectorAll('input[name="controlMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const mode = e.target.id.replace('Mode', '');
                switchControlMode(mode);
                addLog(`Switched to ${mode} control mode`, 'info');
            });
        });

        // ========== PRESET UI FUNCTIONS ==========
        function saveCurrentAsPreset() {
            const currentPos = parseFloat(document.getElementById('currentPosition').textContent);
            if (isNaN(currentPos)) {
                addLog('No position available to save', 'warning');
                return;
            }

            const name = prompt('Enter preset name:', `Position ${currentPos.toFixed(3)}`);
            if (!name) return;

            try {
                const preset = presetManager.addPreset(name, currentPos);
                renderPresetList();
                addLog(`Preset "${name}" saved at ${currentPos.toFixed(3)} turns (hotkey: ${preset.hotkey})`, 'success');
            } catch (e) {
                addLog(`Error saving preset: ${e.message}`, 'danger');
            }
        }

        function goToPreset(id) {
            const position = presetManager.goToPreset(id);
            if (position !== null) {
                const scaledPosition = position * positionScaleFactor;
                socket.emit('set_position', { position: scaledPosition });
                const preset = presetManager.data.presets.find(p => p.id === id);
                addLog(`Going to preset "${preset.name}": ${position.toFixed(3)} turns`, 'info');
            }
        }

        function openPresetManager() {
            renderPresetManagerList();
            const modal = new bootstrap.Modal(document.getElementById('presetManagerModal'));
            modal.show();
        }

        function renderPresetList() {
            const container = document.getElementById('presetsList');
            if (presetManager.data.presets.length === 0) {
                container.innerHTML = '<small class="text-muted">No presets saved</small>';
                return;
            }

            let html = '';
            presetManager.data.presets.forEach(preset => {
                html += `
                    <button class="btn btn-sm preset-btn"
                            style="background-color: ${preset.color}; color: white; border-color: ${preset.color};"
                            onclick="goToPreset('${preset.id}')"
                            title="Hotkey: ${preset.hotkey}">
                        ${preset.name} <span class="badge bg-light text-dark">${preset.hotkey}</span>
                    </button>
                `;
            });
            container.innerHTML = html;
        }

        function renderPresetManagerList() {
            const container = document.getElementById('presetManagerList');
            if (presetManager.data.presets.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">No presets saved</p>';
                return;
            }

            let html = '<div class="list-group">';
            presetManager.data.presets.forEach(preset => {
                html += `
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${preset.name}</strong><br>
                                <small class="text-muted">Position: ${preset.position.toFixed(3)} turns | Hotkey: ${preset.hotkey}</small>
                            </div>
                            <button class="btn btn-sm btn-outline-danger" onclick="deletePreset('${preset.id}')">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function deletePreset(id) {
            if (confirm('Delete this preset?')) {
                presetManager.removePreset(id);
                renderPresetList();
                renderPresetManagerList();
                addLog('Preset deleted', 'info');
            }
        }

        // ========== WAYPOINT UI FUNCTIONS ==========
        function executeWaypoint() {
            const select = document.getElementById('waypointSelect');
            const waypointId = select.value;
            if (!waypointId) {
                addLog('Please select a waypoint to execute', 'warning');
                return;
            }

            waypointExecutor.executeWaypoint(waypointId).catch(e => {
                addLog(`Waypoint execution error: ${e.message}`, 'danger');
                waypointExecutor.stop();
            });
        }

        function stopWaypoint() {
            waypointExecutor.stop();
            addLog('Waypoint execution stopped', 'warning');
        }

        function openWaypointBuilder() {
            // Clear previous inputs
            document.getElementById('waypointName').value = '';
            document.getElementById('waypointPositionsList').innerHTML = '';
            document.getElementById('waypointPauseDuration').value = 1000;
            document.getElementById('waypointLoop').checked = false;

            // Add first position input
            addWaypointPosition();

            const modal = new bootstrap.Modal(document.getElementById('waypointBuilderModal'));
            modal.show();
        }

        function addWaypointPosition() {
            const container = document.getElementById('waypointPositionsList');
            const index = container.children.length;

            const div = document.createElement('div');
            div.className = 'input-group mb-2';
            div.innerHTML = `
                <span class="input-group-text">${index + 1}</span>
                <input type="number" class="form-control waypoint-position-input"
                       placeholder="Position (turns)" step="0.1" value="0">
                <button class="btn btn-outline-danger" onclick="removeWaypointPosition(this)" type="button">Ã—</button>
            `;
            container.appendChild(div);
        }

        function removeWaypointPosition(button) {
            button.parentElement.remove();
            // Renumber remaining positions
            const container = document.getElementById('waypointPositionsList');
            Array.from(container.children).forEach((child, index) => {
                child.querySelector('.input-group-text').textContent = index + 1;
            });
        }

        function saveWaypoint() {
            const name = document.getElementById('waypointName').value.trim();
            if (!name) {
                addLog('Please enter a waypoint name', 'warning');
                return;
            }

            const positionInputs = document.querySelectorAll('.waypoint-position-input');
            const positions = Array.from(positionInputs).map(input => parseFloat(input.value));

            if (positions.length === 0) {
                addLog('Please add at least one position', 'warning');
                return;
            }

            if (positions.some(isNaN)) {
                addLog('All positions must be valid numbers', 'warning');
                return;
            }

            const pauseDuration = parseInt(document.getElementById('waypointPauseDuration').value);
            const loop = document.getElementById('waypointLoop').checked;

            try {
                presetManager.addWaypoint(name, positions, pauseDuration, loop);
                populateWaypointSelect();
                addLog(`Waypoint "${name}" created with ${positions.length} positions`, 'success');

                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('waypointBuilderModal'));
                modal.hide();
            } catch (e) {
                addLog(`Error creating waypoint: ${e.message}`, 'danger');
            }
        }

        function populateWaypointSelect() {
            const select = document.getElementById('waypointSelect');
            const currentValue = select.value;

            let html = '<option value="">-- Select Waypoint --</option>';
            presetManager.data.waypoints.forEach(waypoint => {
                html += `<option value="${waypoint.id}">${waypoint.name} (${waypoint.positions.length} steps)</option>`;
            });

            select.innerHTML = html;
            select.value = currentValue; // Restore selection if possible
        }

        // ========== KEYBOARD SHORTCUT UI FUNCTIONS ==========
        function updateShortcutsToggleUI() {
            const toggleText = document.getElementById('toggleShortcutsText');
            if (toggleText) {
                toggleText.textContent = keyboardShortcutManager.enabled ? 'Disable Shortcuts' : 'Enable Shortcuts';
            }
        }

        // ========== CALIBRATION UI FUNCTIONS ==========
        function startCalibration() {
            if (calibrationExecutor.isCalibrating) {
                addLog('Calibration already in progress', 'warning');
                return;
            }

            const confirmed = confirm(
                'This will automatically move the motor to zero, rotate 1 turn, and return to zero to calibrate the position scale factor.\n\n' +
                'Ensure the motor can safely rotate and nothing will be damaged.\n\n' +
                'Continue with calibration?'
            );

            if (!confirmed) return;

            addLog('Starting auto-calibration...', 'info');
            calibrationExecutor.startCalibration().catch(error => {
                addLog(`Calibration failed: ${error.message}`, 'danger');
            });
        }

        function applyCalibrationResults() {
            const recommendedScaleFactor = calibrationExecutor.getRecommendedScaleFactor();

            if (recommendedScaleFactor > 0) {
                // Update the scale factor
                const scaleFactorSlider = document.getElementById('positionScaleFactor');
                if (scaleFactorSlider) {
                    scaleFactorSlider.value = recommendedScaleFactor;
                    updateScaleFactorDisplay(recommendedScaleFactor);
                }

                addLog(`Scale factor updated to ${recommendedScaleFactor.toFixed(2)}x`, 'success');

                // Close the modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('calibrationResultsModal'));
                if (modal) modal.hide();
            } else {
                addLog('No recommended scale factor available', 'warning');
            }
        }

        // ========== SESSION RECORDING/PLAYBACK UI FUNCTIONS ==========
        let recordingDurationTimer = null;
        let sequenceStorage = []; // In-memory storage for sequences

        function startRecording() {
            const sessionName = prompt('Enter session name (optional):', `Recording_${new Date().toLocaleTimeString()}`);

            try {
                sessionRecorder.startRecording(sessionName || undefined);

                // Update UI
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('recordingIndicator').style.display = 'block';

                // Start duration display timer
                recordingDurationTimer = setInterval(() => {
                    const duration = sessionRecorder.getDuration();
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    document.getElementById('recordingDuration').textContent =
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 100);

            } catch (error) {
                addLog(`Recording error: ${error.message}`, 'danger');
            }
        }

        function stopRecording() {
            try {
                const sessionData = sessionRecorder.stopRecording();

                if (sessionData) {
                    // Save to memory
                    sequenceStorage.push(sessionData);
                    populateSequenceSelect();

                    // Send to backend for persistent storage (if available)
                    socket.emit('save_session', sessionData);
                }

                // Update UI
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('recordingIndicator').style.display = 'none';

                // Stop duration timer
                clearInterval(recordingDurationTimer);

            } catch (error) {
                addLog(`Stop recording error: ${error.message}`, 'danger');
            }
        }

        function populateSequenceSelect() {
            const select = document.getElementById('sequenceSelect');
            const currentValue = select.value;

            let html = '<option value="">-- Select Sequence --</option>';
            sequenceStorage.forEach((session, index) => {
                const duration = session.session_metadata.duration_seconds.toFixed(1);
                const points = session.session_metadata.data_points_count;
                html += `<option value="${index}">${session.session_metadata.name} (${duration}s, ${points} pts)</option>`;
            });

            select.innerHTML = html;
            select.value = currentValue;
        }

        function playSequence() {
            const select = document.getElementById('sequenceSelect');
            const selectedIndex = select.value;

            if (!selectedIndex || selectedIndex === '') {
                addLog('Please select a sequence to play', 'warning');
                return;
            }

            const sessionData = sequenceStorage[parseInt(selectedIndex)];

            try {
                sessionPlayback.loadSession(sessionData);
                sessionPlayback.play();

                // Update UI
                document.getElementById('playSequenceBtn').disabled = true;
                document.getElementById('pauseSequenceBtn').disabled = false;
                document.getElementById('stopSequenceBtn').disabled = false;
                document.getElementById('playbackProgress').style.display = 'block';

                const duration = sessionData.session_metadata.duration_seconds;
                document.getElementById('playbackDuration').textContent = formatTime(duration);

            } catch (error) {
                addLog(`Playback error: ${error.message}`, 'danger');
            }
        }

        function pauseSequence() {
            sessionPlayback.pause();

            // Update UI
            document.getElementById('playSequenceBtn').disabled = false;
            document.getElementById('pauseSequenceBtn').disabled = true;
        }

        function stopSequence() {
            sessionPlayback.stop();

            // Update UI
            document.getElementById('playSequenceBtn').disabled = false;
            document.getElementById('pauseSequenceBtn').disabled = true;
            document.getElementById('stopSequenceBtn').disabled = true;
            document.getElementById('playbackProgress').style.display = 'none';

            // Reset progress bar
            document.getElementById('playbackProgressBar').style.width = '0%';
            document.getElementById('playbackTime').textContent = '0:00';
        }

        function updatePlaybackSpeed(value) {
            const speed = parseFloat(value);
            document.getElementById('playbackSpeedValue').textContent = speed.toFixed(1);
            document.getElementById('playbackSpeed').textContent = speed.toFixed(1) + 'x';

            sessionPlayback.setSpeed(speed);
        }

        function updatePlaybackProgress(progress, currentTime) {
            document.getElementById('playbackProgressBar').style.width = progress + '%';
            document.getElementById('playbackTime').textContent = formatTime(currentTime);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function openSequenceLibrary() {
            renderSequenceLibrary();
            const modal = new bootstrap.Modal(document.getElementById('sequenceLibraryModal'));
            modal.show();
        }

        function renderSequenceLibrary() {
            const container = document.getElementById('sequenceLibraryList');

            if (sequenceStorage.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">No sequences recorded</p>';
                return;
            }

            let html = '<div class="list-group">';
            sequenceStorage.forEach((session, index) => {
                const metadata = session.session_metadata;
                const duration = metadata.duration_seconds.toFixed(1);
                const points = metadata.data_points_count;
                const date = new Date(metadata.start_time).toLocaleString();

                html += `
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${metadata.name}</strong><br>
                                <small class="text-muted">
                                    Duration: ${duration}s | Points: ${points} | ${date}
                                </small>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-sm btn-outline-primary" onclick="loadAndPlaySequence(${index})">
                                    <i class="bi bi-play"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-success" onclick="downloadSequence(${index})">
                                    <i class="bi bi-download"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteSequenceByIndex(${index})">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function loadAndPlaySequence(index) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('sequenceLibraryModal'));
            if (modal) modal.hide();

            // Set selection and play
            document.getElementById('sequenceSelect').value = index;
            playSequence();
        }

        function downloadSequence(index) {
            const sessionData = sequenceStorage[index];
            const dataStr = JSON.stringify(sessionData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${sessionData.session_metadata.name}.json`;
            a.click();

            URL.revokeObjectURL(url);
            addLog(`Downloaded: ${sessionData.session_metadata.name}.json`, 'success');
        }

        function deleteSequenceByIndex(index) {
            const sessionData = sequenceStorage[index];

            if (confirm(`Delete sequence "${sessionData.session_metadata.name}"?`)) {
                sequenceStorage.splice(index, 1);
                populateSequenceSelect();
                renderSequenceLibrary();
                addLog('Sequence deleted', 'info');
            }
        }

        function deleteSequence() {
            const select = document.getElementById('sequenceSelect');
            const selectedIndex = select.value;

            if (!selectedIndex || selectedIndex === '') {
                addLog('Please select a sequence to delete', 'warning');
                return;
            }

            deleteSequenceByIndex(parseInt(selectedIndex));
        }

        // ========== VELOCITY RAMPING UI FUNCTIONS ==========
        function updateAccelerationDisplay(value) {
            const accel = parseFloat(value);
            document.getElementById('accelerationValue').textContent = accel.toFixed(1);

            // Send to backend
            socket.emit('set_velocity_ramp', {
                acceleration: accel,
                deceleration: parseFloat(document.getElementById('decelerationLimit').value)
            });

            localStorage.setItem('accelerationLimit', value);
            addLog(`Acceleration limit set to ${accel.toFixed(1)} turns/secÂ²`, 'info');
        }

        function updateDecelerationDisplay(value) {
            const decel = parseFloat(value);
            document.getElementById('decelerationValue').textContent = decel.toFixed(1);

            // Send to backend
            socket.emit('set_velocity_ramp', {
                acceleration: parseFloat(document.getElementById('accelerationLimit').value),
                deceleration: decel
            });

            localStorage.setItem('decelerationLimit', value);
            addLog(`Deceleration limit set to ${decel.toFixed(1)} turns/secÂ²`, 'info');
        }

        function toggleVelocityRamping(enabled) {
            const controlsDiv = document.getElementById('velocityRampingControls');
            controlsDiv.style.opacity = enabled ? '1' : '0.5';

            // Send to backend
            socket.emit('set_velocity_ramp_enabled', { enabled: enabled });

            localStorage.setItem('velocityRampingEnabled', enabled);
            addLog(`Velocity ramping ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        // Load velocity ramping settings from localStorage on page load
        window.addEventListener('DOMContentLoaded', function() {
            const savedAccel = localStorage.getItem('accelerationLimit');
            const savedDecel = localStorage.getItem('decelerationLimit');
            const savedEnabled = localStorage.getItem('velocityRampingEnabled');

            if (savedAccel) {
                document.getElementById('accelerationLimit').value = savedAccel;
                updateAccelerationDisplay(savedAccel);
            }

            if (savedDecel) {
                document.getElementById('decelerationLimit').value = savedDecel;
                updateDecelerationDisplay(savedDecel);
            }

            if (savedEnabled !== null) {
                const enabled = savedEnabled === 'true';
                document.getElementById('velocityRampingEnabled').checked = enabled;
                toggleVelocityRamping(enabled);
            }
        });

        // Initialize presets and waypoints on page load
        window.addEventListener('DOMContentLoaded', function() {
            renderPresetList();
            populateWaypointSelect();
            addLog('Presets and waypoints loaded', 'info');

            // Load saved control mode into UI selects
            const savedControlMode = localStorage.getItem('savedControlMode');
            const savedInputMode = localStorage.getItem('savedInputMode');
            if (savedControlMode !== null) {
                const controlSelect = document.getElementById('controlModeSelect');
                if (controlSelect) controlSelect.value = parseInt(savedControlMode);
            }
            if (savedInputMode !== null) {
                const inputSelect = document.getElementById('inputModeSelect');
                if (inputSelect) inputSelect.value = parseInt(savedInputMode);
            }
        });

        // Initialize rotation knob on page load
        createRotationKnob();

    </script>
</body>
</html>
</body></html>
